{"version":3,"file":"static/js/416.eeba4c39.chunk.js","mappings":"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","sources":["../node_modules/chess.js/src/chess.ts","../node_modules/@babel/runtime/helpers/esm/defineProperty.js","../node_modules/@babel/runtime/helpers/esm/toPrimitive.js","../node_modules/@babel/runtime/helpers/esm/toPropertyKey.js","../node_modules/@babel/runtime/helpers/esm/typeof.js","../node_modules/dexie/dist/modern/dexie.mjs"],"sourcesContent":["/**\n * @license\n * Copyright (c) 2023, Jeff Hlywa (jhlywa@gmail.com)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\nexport const WHITE = 'w'\nexport const BLACK = 'b'\n\nexport const PAWN = 'p'\nexport const KNIGHT = 'n'\nexport const BISHOP = 'b'\nexport const ROOK = 'r'\nexport const QUEEN = 'q'\nexport const KING = 'k'\n\nexport type Color = 'w' | 'b'\nexport type PieceSymbol = 'p' | 'n' | 'b' | 'r' | 'q' | 'k'\n\n// prettier-ignore\nexport type Square =\n    'a8' | 'b8' | 'c8' | 'd8' | 'e8' | 'f8' | 'g8' | 'h8' |\n    'a7' | 'b7' | 'c7' | 'd7' | 'e7' | 'f7' | 'g7' | 'h7' |\n    'a6' | 'b6' | 'c6' | 'd6' | 'e6' | 'f6' | 'g6' | 'h6' |\n    'a5' | 'b5' | 'c5' | 'd5' | 'e5' | 'f5' | 'g5' | 'h5' |\n    'a4' | 'b4' | 'c4' | 'd4' | 'e4' | 'f4' | 'g4' | 'h4' |\n    'a3' | 'b3' | 'c3' | 'd3' | 'e3' | 'f3' | 'g3' | 'h3' |\n    'a2' | 'b2' | 'c2' | 'd2' | 'e2' | 'f2' | 'g2' | 'h2' |\n    'a1' | 'b1' | 'c1' | 'd1' | 'e1' | 'f1' | 'g1' | 'h1'\n\nexport const DEFAULT_POSITION =\n  'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1'\n\nexport type Piece = {\n  color: Color\n  type: PieceSymbol\n}\n\ntype InternalMove = {\n  color: Color\n  from: number\n  to: number\n  piece: PieceSymbol\n  captured?: PieceSymbol\n  promotion?: PieceSymbol\n  flags: number\n}\n\ninterface History {\n  move: InternalMove\n  kings: Record<Color, number>\n  turn: Color\n  castling: Record<Color, number>\n  epSquare: number\n  halfMoves: number\n  moveNumber: number\n}\n\nexport type Move = {\n  color: Color\n  from: Square\n  to: Square\n  piece: PieceSymbol\n  captured?: PieceSymbol\n  promotion?: PieceSymbol\n  flags: string\n  san: string\n  lan: string\n  before: string\n  after: string\n}\n\nconst EMPTY = -1\n\nconst FLAGS: Record<string, string> = {\n  NORMAL: 'n',\n  CAPTURE: 'c',\n  BIG_PAWN: 'b',\n  EP_CAPTURE: 'e',\n  PROMOTION: 'p',\n  KSIDE_CASTLE: 'k',\n  QSIDE_CASTLE: 'q',\n}\n\n// prettier-ignore\nexport const SQUARES: Square[] = [\n  'a8', 'b8', 'c8', 'd8', 'e8', 'f8', 'g8', 'h8',\n  'a7', 'b7', 'c7', 'd7', 'e7', 'f7', 'g7', 'h7',\n  'a6', 'b6', 'c6', 'd6', 'e6', 'f6', 'g6', 'h6',\n  'a5', 'b5', 'c5', 'd5', 'e5', 'f5', 'g5', 'h5',\n  'a4', 'b4', 'c4', 'd4', 'e4', 'f4', 'g4', 'h4',\n  'a3', 'b3', 'c3', 'd3', 'e3', 'f3', 'g3', 'h3',\n  'a2', 'b2', 'c2', 'd2', 'e2', 'f2', 'g2', 'h2',\n  'a1', 'b1', 'c1', 'd1', 'e1', 'f1', 'g1', 'h1'\n]\n\nconst BITS: Record<string, number> = {\n  NORMAL: 1,\n  CAPTURE: 2,\n  BIG_PAWN: 4,\n  EP_CAPTURE: 8,\n  PROMOTION: 16,\n  KSIDE_CASTLE: 32,\n  QSIDE_CASTLE: 64,\n}\n\n/*\n * NOTES ABOUT 0x88 MOVE GENERATION ALGORITHM\n * ----------------------------------------------------------------------------\n * From https://github.com/jhlywa/chess.js/issues/230\n *\n * A lot of people are confused when they first see the internal representation\n * of chess.js. It uses the 0x88 Move Generation Algorithm which internally\n * stores the board as an 8x16 array. This is purely for efficiency but has a\n * couple of interesting benefits:\n *\n * 1. 0x88 offers a very inexpensive \"off the board\" check. Bitwise AND (&) any\n *    square with 0x88, if the result is non-zero then the square is off the\n *    board. For example, assuming a knight square A8 (0 in 0x88 notation),\n *    there are 8 possible directions in which the knight can move. These\n *    directions are relative to the 8x16 board and are stored in the\n *    PIECE_OFFSETS map. One possible move is A8 - 18 (up one square, and two\n *    squares to the left - which is off the board). 0 - 18 = -18 & 0x88 = 0x88\n *    (because of two-complement representation of -18). The non-zero result\n *    means the square is off the board and the move is illegal. Take the\n *    opposite move (from A8 to C7), 0 + 18 = 18 & 0x88 = 0. A result of zero\n *    means the square is on the board.\n *\n * 2. The relative distance (or difference) between two squares on a 8x16 board\n *    is unique and can be used to inexpensively determine if a piece on a\n *    square can attack any other arbitrary square. For example, let's see if a\n *    pawn on E7 can attack E2. The difference between E7 (20) - E2 (100) is\n *    -80. We add 119 to make the ATTACKS array index non-negative (because the\n *    worst case difference is A8 - H1 = -119). The ATTACKS array contains a\n *    bitmask of pieces that can attack from that distance and direction.\n *    ATTACKS[-80 + 119=39] gives us 24 or 0b11000 in binary. Look at the\n *    PIECE_MASKS map to determine the mask for a given piece type. In our pawn\n *    example, we would check to see if 24 & 0x1 is non-zero, which it is\n *    not. So, naturally, a pawn on E7 can't attack a piece on E2. However, a\n *    rook can since 24 & 0x8 is non-zero. The only thing left to check is that\n *    there are no blocking pieces between E7 and E2. That's where the RAYS\n *    array comes in. It provides an offset (in this case 16) to add to E7 (20)\n *    to check for blocking pieces. E7 (20) + 16 = E6 (36) + 16 = E5 (52) etc.\n */\n\n// prettier-ignore\n// eslint-disable-next-line\nconst Ox88: Record<Square, number> = {\n  a8:   0, b8:   1, c8:   2, d8:   3, e8:   4, f8:   5, g8:   6, h8:   7,\n  a7:  16, b7:  17, c7:  18, d7:  19, e7:  20, f7:  21, g7:  22, h7:  23,\n  a6:  32, b6:  33, c6:  34, d6:  35, e6:  36, f6:  37, g6:  38, h6:  39,\n  a5:  48, b5:  49, c5:  50, d5:  51, e5:  52, f5:  53, g5:  54, h5:  55,\n  a4:  64, b4:  65, c4:  66, d4:  67, e4:  68, f4:  69, g4:  70, h4:  71,\n  a3:  80, b3:  81, c3:  82, d3:  83, e3:  84, f3:  85, g3:  86, h3:  87,\n  a2:  96, b2:  97, c2:  98, d2:  99, e2: 100, f2: 101, g2: 102, h2: 103,\n  a1: 112, b1: 113, c1: 114, d1: 115, e1: 116, f1: 117, g1: 118, h1: 119\n}\n\nconst PAWN_OFFSETS = {\n  b: [16, 32, 17, 15],\n  w: [-16, -32, -17, -15],\n}\n\nconst PIECE_OFFSETS = {\n  n: [-18, -33, -31, -14, 18, 33, 31, 14],\n  b: [-17, -15, 17, 15],\n  r: [-16, 1, 16, -1],\n  q: [-17, -16, -15, 1, 17, 16, 15, -1],\n  k: [-17, -16, -15, 1, 17, 16, 15, -1],\n}\n\n// prettier-ignore\nconst ATTACKS = [\n  20, 0, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0, 0,20, 0,\n   0,20, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0,20, 0, 0,\n   0, 0,20, 0, 0, 0, 0, 24,  0, 0, 0, 0,20, 0, 0, 0,\n   0, 0, 0,20, 0, 0, 0, 24,  0, 0, 0,20, 0, 0, 0, 0,\n   0, 0, 0, 0,20, 0, 0, 24,  0, 0,20, 0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,20, 2, 24,  2,20, 0, 0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0, 2,53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\n  24,24,24,24,24,24,56,  0, 56,24,24,24,24,24,24, 0,\n   0, 0, 0, 0, 0, 2,53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,20, 2, 24,  2,20, 0, 0, 0, 0, 0, 0,\n   0, 0, 0, 0,20, 0, 0, 24,  0, 0,20, 0, 0, 0, 0, 0,\n   0, 0, 0,20, 0, 0, 0, 24,  0, 0, 0,20, 0, 0, 0, 0,\n   0, 0,20, 0, 0, 0, 0, 24,  0, 0, 0, 0,20, 0, 0, 0,\n   0,20, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0,20, 0, 0,\n  20, 0, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0, 0,20\n];\n\n// prettier-ignore\nconst RAYS = [\n   17,  0,  0,  0,  0,  0,  0, 16,  0,  0,  0,  0,  0,  0, 15, 0,\n    0, 17,  0,  0,  0,  0,  0, 16,  0,  0,  0,  0,  0, 15,  0, 0,\n    0,  0, 17,  0,  0,  0,  0, 16,  0,  0,  0,  0, 15,  0,  0, 0,\n    0,  0,  0, 17,  0,  0,  0, 16,  0,  0,  0, 15,  0,  0,  0, 0,\n    0,  0,  0,  0, 17,  0,  0, 16,  0,  0, 15,  0,  0,  0,  0, 0,\n    0,  0,  0,  0,  0, 17,  0, 16,  0, 15,  0,  0,  0,  0,  0, 0,\n    0,  0,  0,  0,  0,  0, 17, 16, 15,  0,  0,  0,  0,  0,  0, 0,\n    1,  1,  1,  1,  1,  1,  1,  0, -1, -1,  -1,-1, -1, -1, -1, 0,\n    0,  0,  0,  0,  0,  0,-15,-16,-17,  0,  0,  0,  0,  0,  0, 0,\n    0,  0,  0,  0,  0,-15,  0,-16,  0,-17,  0,  0,  0,  0,  0, 0,\n    0,  0,  0,  0,-15,  0,  0,-16,  0,  0,-17,  0,  0,  0,  0, 0,\n    0,  0,  0,-15,  0,  0,  0,-16,  0,  0,  0,-17,  0,  0,  0, 0,\n    0,  0,-15,  0,  0,  0,  0,-16,  0,  0,  0,  0,-17,  0,  0, 0,\n    0,-15,  0,  0,  0,  0,  0,-16,  0,  0,  0,  0,  0,-17,  0, 0,\n  -15,  0,  0,  0,  0,  0,  0,-16,  0,  0,  0,  0,  0,  0,-17\n];\n\nconst PIECE_MASKS = { p: 0x1, n: 0x2, b: 0x4, r: 0x8, q: 0x10, k: 0x20 }\n\nconst SYMBOLS = 'pnbrqkPNBRQK'\n\nconst PROMOTIONS: PieceSymbol[] = [KNIGHT, BISHOP, ROOK, QUEEN]\n\nconst RANK_1 = 7\nconst RANK_2 = 6\n/*\n * const RANK_3 = 5\n * const RANK_4 = 4\n * const RANK_5 = 3\n * const RANK_6 = 2\n */\nconst RANK_7 = 1\nconst RANK_8 = 0\n\nconst SIDES = {\n  [KING]: BITS.KSIDE_CASTLE,\n  [QUEEN]: BITS.QSIDE_CASTLE,\n}\n\nconst ROOKS = {\n  w: [\n    { square: Ox88.a1, flag: BITS.QSIDE_CASTLE },\n    { square: Ox88.h1, flag: BITS.KSIDE_CASTLE },\n  ],\n  b: [\n    { square: Ox88.a8, flag: BITS.QSIDE_CASTLE },\n    { square: Ox88.h8, flag: BITS.KSIDE_CASTLE },\n  ],\n}\n\nconst SECOND_RANK = { b: RANK_7, w: RANK_2 }\n\nconst TERMINATION_MARKERS = ['1-0', '0-1', '1/2-1/2', '*']\n\n// Extracts the zero-based rank of an 0x88 square.\nfunction rank(square: number): number {\n  return square >> 4\n}\n\n// Extracts the zero-based file of an 0x88 square.\nfunction file(square: number): number {\n  return square & 0xf\n}\n\nfunction isDigit(c: string): boolean {\n  return '0123456789'.indexOf(c) !== -1\n}\n\n// Converts a 0x88 square to algebraic notation.\nfunction algebraic(square: number): Square {\n  const f = file(square)\n  const r = rank(square)\n  return ('abcdefgh'.substring(f, f + 1) +\n    '87654321'.substring(r, r + 1)) as Square\n}\n\nfunction swapColor(color: Color): Color {\n  return color === WHITE ? BLACK : WHITE\n}\n\nexport function validateFen(fen: string) {\n  // 1st criterion: 6 space-seperated fields?\n  const tokens = fen.split(/\\s+/)\n  if (tokens.length !== 6) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: must contain six space-delimited fields',\n    }\n  }\n\n  // 2nd criterion: move number field is a integer value > 0?\n  const moveNumber = parseInt(tokens[5], 10)\n  if (isNaN(moveNumber) || moveNumber <= 0) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: move number must be a positive integer',\n    }\n  }\n\n  // 3rd criterion: half move counter is an integer >= 0?\n  const halfMoves = parseInt(tokens[4], 10)\n  if (isNaN(halfMoves) || halfMoves < 0) {\n    return {\n      ok: false,\n      error:\n        'Invalid FEN: half move counter number must be a non-negative integer',\n    }\n  }\n\n  // 4th criterion: 4th field is a valid e.p.-string?\n  if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) {\n    return { ok: false, error: 'Invalid FEN: en-passant square is invalid' }\n  }\n\n  // 5th criterion: 3th field is a valid castle-string?\n  if (/[^kKqQ-]/.test(tokens[2])) {\n    return { ok: false, error: 'Invalid FEN: castling availability is invalid' }\n  }\n\n  // 6th criterion: 2nd field is \"w\" (white) or \"b\" (black)?\n  if (!/^(w|b)$/.test(tokens[1])) {\n    return { ok: false, error: 'Invalid FEN: side-to-move is invalid' }\n  }\n\n  // 7th criterion: 1st field contains 8 rows?\n  const rows = tokens[0].split('/')\n  if (rows.length !== 8) {\n    return {\n      ok: false,\n      error: \"Invalid FEN: piece data does not contain 8 '/'-delimited rows\",\n    }\n  }\n\n  // 8th criterion: every row is valid?\n  for (let i = 0; i < rows.length; i++) {\n    // check for right sum of fields AND not two numbers in succession\n    let sumFields = 0\n    let previousWasNumber = false\n\n    for (let k = 0; k < rows[i].length; k++) {\n      if (isDigit(rows[i][k])) {\n        if (previousWasNumber) {\n          return {\n            ok: false,\n            error: 'Invalid FEN: piece data is invalid (consecutive number)',\n          }\n        }\n        sumFields += parseInt(rows[i][k], 10)\n        previousWasNumber = true\n      } else {\n        if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) {\n          return {\n            ok: false,\n            error: 'Invalid FEN: piece data is invalid (invalid piece)',\n          }\n        }\n        sumFields += 1\n        previousWasNumber = false\n      }\n    }\n    if (sumFields !== 8) {\n      return {\n        ok: false,\n        error: 'Invalid FEN: piece data is invalid (too many squares in rank)',\n      }\n    }\n  }\n\n  // 9th criterion: is en-passant square legal?\n  if (\n    (tokens[3][1] == '3' && tokens[1] == 'w') ||\n    (tokens[3][1] == '6' && tokens[1] == 'b')\n  ) {\n    return { ok: false, error: 'Invalid FEN: illegal en-passant square' }\n  }\n\n  // 10th criterion: does chess position contain exact two kings?\n  const kings = [\n    { color: 'white', regex: /K/g },\n    { color: 'black', regex: /k/g },\n  ]\n\n  for (const { color, regex } of kings) {\n    if (!regex.test(tokens[0])) {\n      return { ok: false, error: `Invalid FEN: missing ${color} king` }\n    }\n\n    if ((tokens[0].match(regex) || []).length > 1) {\n      return { ok: false, error: `Invalid FEN: too many ${color} kings` }\n    }\n  }\n\n  // 11th criterion: are any pawns on the first or eighth rows?\n  if (\n    Array.from(rows[0] + rows[7]).some((char) => char.toUpperCase() === 'P')\n  ) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: some pawns are on the edge rows',\n    }\n  }\n\n  return { ok: true }\n}\n\n// this function is used to uniquely identify ambiguous moves\nfunction getDisambiguator(move: InternalMove, moves: InternalMove[]) {\n  const from = move.from\n  const to = move.to\n  const piece = move.piece\n\n  let ambiguities = 0\n  let sameRank = 0\n  let sameFile = 0\n\n  for (let i = 0, len = moves.length; i < len; i++) {\n    const ambigFrom = moves[i].from\n    const ambigTo = moves[i].to\n    const ambigPiece = moves[i].piece\n\n    /*\n     * if a move of the same piece type ends on the same to square, we'll need\n     * to add a disambiguator to the algebraic notation\n     */\n    if (piece === ambigPiece && from !== ambigFrom && to === ambigTo) {\n      ambiguities++\n\n      if (rank(from) === rank(ambigFrom)) {\n        sameRank++\n      }\n\n      if (file(from) === file(ambigFrom)) {\n        sameFile++\n      }\n    }\n  }\n\n  if (ambiguities > 0) {\n    if (sameRank > 0 && sameFile > 0) {\n      /*\n       * if there exists a similar moving piece on the same rank and file as\n       * the move in question, use the square as the disambiguator\n       */\n      return algebraic(from)\n    } else if (sameFile > 0) {\n      /*\n       * if the moving piece rests on the same file, use the rank symbol as the\n       * disambiguator\n       */\n      return algebraic(from).charAt(1)\n    } else {\n      // else use the file symbol\n      return algebraic(from).charAt(0)\n    }\n  }\n\n  return ''\n}\n\nfunction addMove(\n  moves: InternalMove[],\n  color: Color,\n  from: number,\n  to: number,\n  piece: PieceSymbol,\n  captured: PieceSymbol | undefined = undefined,\n  flags: number = BITS.NORMAL,\n) {\n  const r = rank(to)\n\n  if (piece === PAWN && (r === RANK_1 || r === RANK_8)) {\n    for (let i = 0; i < PROMOTIONS.length; i++) {\n      const promotion = PROMOTIONS[i]\n      moves.push({\n        color,\n        from,\n        to,\n        piece,\n        captured,\n        promotion,\n        flags: flags | BITS.PROMOTION,\n      })\n    }\n  } else {\n    moves.push({\n      color,\n      from,\n      to,\n      piece,\n      captured,\n      flags,\n    })\n  }\n}\n\nfunction inferPieceType(san: string) {\n  let pieceType = san.charAt(0)\n  if (pieceType >= 'a' && pieceType <= 'h') {\n    const matches = san.match(/[a-h]\\d.*[a-h]\\d/)\n    if (matches) {\n      return undefined\n    }\n    return PAWN\n  }\n  pieceType = pieceType.toLowerCase()\n  if (pieceType === 'o') {\n    return KING\n  }\n  return pieceType as PieceSymbol\n}\n\n// parses all of the decorators out of a SAN string\nfunction strippedSan(move: string) {\n  return move.replace(/=/, '').replace(/[+#]?[?!]*$/, '')\n}\n\nfunction trimFen(fen: string): string {\n  /*\n   * remove last two fields in FEN string as they're not needed when checking\n   * for repetition\n   */\n  return fen.split(' ').slice(0, 4).join(' ')\n}\n\nexport class Chess {\n  private _board = new Array<Piece>(128)\n  private _turn: Color = WHITE\n  private _header: Record<string, string> = {}\n  private _kings: Record<Color, number> = { w: EMPTY, b: EMPTY }\n  private _epSquare = -1\n  private _halfMoves = 0\n  private _moveNumber = 0\n  private _history: History[] = []\n  private _comments: Record<string, string> = {}\n  private _castling: Record<Color, number> = { w: 0, b: 0 }\n  private _positionCounts: Record<string, number> = {}\n\n  constructor(fen = DEFAULT_POSITION) {\n    this.load(fen)\n  }\n\n  clear({ preserveHeaders = false } = {}) {\n    this._board = new Array<Piece>(128)\n    this._kings = { w: EMPTY, b: EMPTY }\n    this._turn = WHITE\n    this._castling = { w: 0, b: 0 }\n    this._epSquare = EMPTY\n    this._halfMoves = 0\n    this._moveNumber = 1\n    this._history = []\n    this._comments = {}\n    this._header = preserveHeaders ? this._header : {}\n\n    /*\n     * Delete the SetUp and FEN headers (if preserved), the board is empty and\n     * these headers don't make sense in this state. They'll get added later\n     * via .load() or .put()\n     */\n    delete this._header['SetUp']\n    delete this._header['FEN']\n\n    /*\n     * Instantiate a proxy that keeps track of position occurrence counts for the purpose\n     * of repetition checking. The getter and setter methods automatically handle trimming\n     * irrelevent information from the fen, initialising new positions, and removing old\n     * positions from the record if their counts are reduced to 0.\n     */\n    this._positionCounts = new Proxy({} as Record<string, number>, {\n      get: (target, position: string) =>\n        position === 'length'\n          ? Object.keys(target).length // length for unit testing\n          : target?.[trimFen(position)] || 0,\n      set: (target, position: string, count: number) => {\n        const trimmedFen = trimFen(position)\n        if (count === 0) delete target[trimmedFen]\n        else target[trimmedFen] = count\n        return true\n      },\n    })\n  }\n\n  removeHeader(key: string) {\n    if (key in this._header) {\n      delete this._header[key]\n    }\n  }\n\n  load(fen: string, { skipValidation = false, preserveHeaders = false } = {}) {\n    let tokens = fen.split(/\\s+/)\n\n    // append commonly omitted fen tokens\n    if (tokens.length >= 2 && tokens.length < 6) {\n      const adjustments = ['-', '-', '0', '1']\n      fen = tokens.concat(adjustments.slice(-(6 - tokens.length))).join(' ')\n    }\n\n    tokens = fen.split(/\\s+/)\n\n    if (!skipValidation) {\n      const { ok, error } = validateFen(fen)\n      if (!ok) {\n        throw new Error(error)\n      }\n    }\n\n    const position = tokens[0]\n    let square = 0\n\n    this.clear({ preserveHeaders })\n\n    for (let i = 0; i < position.length; i++) {\n      const piece = position.charAt(i)\n\n      if (piece === '/') {\n        square += 8\n      } else if (isDigit(piece)) {\n        square += parseInt(piece, 10)\n      } else {\n        const color = piece < 'a' ? WHITE : BLACK\n        this._put(\n          { type: piece.toLowerCase() as PieceSymbol, color },\n          algebraic(square),\n        )\n        square++\n      }\n    }\n\n    this._turn = tokens[1] as Color\n\n    if (tokens[2].indexOf('K') > -1) {\n      this._castling.w |= BITS.KSIDE_CASTLE\n    }\n    if (tokens[2].indexOf('Q') > -1) {\n      this._castling.w |= BITS.QSIDE_CASTLE\n    }\n    if (tokens[2].indexOf('k') > -1) {\n      this._castling.b |= BITS.KSIDE_CASTLE\n    }\n    if (tokens[2].indexOf('q') > -1) {\n      this._castling.b |= BITS.QSIDE_CASTLE\n    }\n\n    this._epSquare = tokens[3] === '-' ? EMPTY : Ox88[tokens[3] as Square]\n    this._halfMoves = parseInt(tokens[4], 10)\n    this._moveNumber = parseInt(tokens[5], 10)\n\n    this._updateSetup(fen)\n    this._positionCounts[fen]++\n  }\n\n  fen() {\n    let empty = 0\n    let fen = ''\n\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      if (this._board[i]) {\n        if (empty > 0) {\n          fen += empty\n          empty = 0\n        }\n        const { color, type: piece } = this._board[i]\n\n        fen += color === WHITE ? piece.toUpperCase() : piece.toLowerCase()\n      } else {\n        empty++\n      }\n\n      if ((i + 1) & 0x88) {\n        if (empty > 0) {\n          fen += empty\n        }\n\n        if (i !== Ox88.h1) {\n          fen += '/'\n        }\n\n        empty = 0\n        i += 8\n      }\n    }\n\n    let castling = ''\n    if (this._castling[WHITE] & BITS.KSIDE_CASTLE) {\n      castling += 'K'\n    }\n    if (this._castling[WHITE] & BITS.QSIDE_CASTLE) {\n      castling += 'Q'\n    }\n    if (this._castling[BLACK] & BITS.KSIDE_CASTLE) {\n      castling += 'k'\n    }\n    if (this._castling[BLACK] & BITS.QSIDE_CASTLE) {\n      castling += 'q'\n    }\n\n    // do we have an empty castling flag?\n    castling = castling || '-'\n\n    let epSquare = '-'\n    /*\n     * only print the ep square if en passant is a valid move (pawn is present\n     * and ep capture is not pinned)\n     */\n    if (this._epSquare !== EMPTY) {\n      const bigPawnSquare = this._epSquare + (this._turn === WHITE ? 16 : -16)\n      const squares = [bigPawnSquare + 1, bigPawnSquare - 1]\n\n      for (const square of squares) {\n        // is the square off the board?\n        if (square & 0x88) {\n          continue\n        }\n\n        const color = this._turn\n\n        // is there a pawn that can capture the epSquare?\n        if (\n          this._board[square]?.color === color &&\n          this._board[square]?.type === PAWN\n        ) {\n          // if the pawn makes an ep capture, does it leave it's king in check?\n          this._makeMove({\n            color,\n            from: square,\n            to: this._epSquare,\n            piece: PAWN,\n            captured: PAWN,\n            flags: BITS.EP_CAPTURE,\n          })\n          const isLegal = !this._isKingAttacked(color)\n          this._undoMove()\n\n          // if ep is legal, break and set the ep square in the FEN output\n          if (isLegal) {\n            epSquare = algebraic(this._epSquare)\n            break\n          }\n        }\n      }\n    }\n\n    return [\n      fen,\n      this._turn,\n      castling,\n      epSquare,\n      this._halfMoves,\n      this._moveNumber,\n    ].join(' ')\n  }\n\n  /*\n   * Called when the initial board setup is changed with put() or remove().\n   * modifies the SetUp and FEN properties of the header object. If the FEN\n   * is equal to the default position, the SetUp and FEN are deleted the setup\n   * is only updated if history.length is zero, ie moves haven't been made.\n   */\n  private _updateSetup(fen: string) {\n    if (this._history.length > 0) return\n\n    if (fen !== DEFAULT_POSITION) {\n      this._header['SetUp'] = '1'\n      this._header['FEN'] = fen\n    } else {\n      delete this._header['SetUp']\n      delete this._header['FEN']\n    }\n  }\n\n  reset() {\n    this.load(DEFAULT_POSITION)\n  }\n\n  get(square: Square) {\n    return this._board[Ox88[square]] || false\n  }\n\n  put({ type, color }: { type: PieceSymbol; color: Color }, square: Square) {\n    if (this._put({ type, color }, square)) {\n      this._updateCastlingRights()\n      this._updateEnPassantSquare()\n      this._updateSetup(this.fen())\n      return true\n    }\n    return false\n  }\n\n  private _put(\n    { type, color }: { type: PieceSymbol; color: Color },\n    square: Square,\n  ) {\n    // check for piece\n    if (SYMBOLS.indexOf(type.toLowerCase()) === -1) {\n      return false\n    }\n\n    // check for valid square\n    if (!(square in Ox88)) {\n      return false\n    }\n\n    const sq = Ox88[square]\n\n    // don't let the user place more than one king\n    if (\n      type == KING &&\n      !(this._kings[color] == EMPTY || this._kings[color] == sq)\n    ) {\n      return false\n    }\n\n    const currentPieceOnSquare = this._board[sq]\n\n    // if one of the kings will be replaced by the piece from args, set the `_kings` respective entry to `EMPTY`\n    if (currentPieceOnSquare && currentPieceOnSquare.type === KING) {\n      this._kings[currentPieceOnSquare.color] = EMPTY\n    }\n\n    this._board[sq] = { type: type as PieceSymbol, color: color as Color }\n\n    if (type === KING) {\n      this._kings[color] = sq\n    }\n\n    return true\n  }\n\n  remove(square: Square) {\n    const piece = this.get(square)\n    delete this._board[Ox88[square]]\n    if (piece && piece.type === KING) {\n      this._kings[piece.color] = EMPTY\n    }\n\n    this._updateCastlingRights()\n    this._updateEnPassantSquare()\n    this._updateSetup(this.fen())\n\n    return piece\n  }\n\n  private _updateCastlingRights() {\n    const whiteKingInPlace =\n      this._board[Ox88.e1]?.type === KING &&\n      this._board[Ox88.e1]?.color === WHITE\n    const blackKingInPlace =\n      this._board[Ox88.e8]?.type === KING &&\n      this._board[Ox88.e8]?.color === BLACK\n\n    if (\n      !whiteKingInPlace ||\n      this._board[Ox88.a1]?.type !== ROOK ||\n      this._board[Ox88.a1]?.color !== WHITE\n    ) {\n      this._castling.w &= ~BITS.QSIDE_CASTLE\n    }\n\n    if (\n      !whiteKingInPlace ||\n      this._board[Ox88.h1]?.type !== ROOK ||\n      this._board[Ox88.h1]?.color !== WHITE\n    ) {\n      this._castling.w &= ~BITS.KSIDE_CASTLE\n    }\n\n    if (\n      !blackKingInPlace ||\n      this._board[Ox88.a8]?.type !== ROOK ||\n      this._board[Ox88.a8]?.color !== BLACK\n    ) {\n      this._castling.b &= ~BITS.QSIDE_CASTLE\n    }\n\n    if (\n      !blackKingInPlace ||\n      this._board[Ox88.h8]?.type !== ROOK ||\n      this._board[Ox88.h8]?.color !== BLACK\n    ) {\n      this._castling.b &= ~BITS.KSIDE_CASTLE\n    }\n  }\n\n  private _updateEnPassantSquare() {\n    if (this._epSquare === EMPTY) {\n      return\n    }\n\n    const startSquare = this._epSquare + (this._turn === WHITE ? -16 : 16)\n    const currentSquare = this._epSquare + (this._turn === WHITE ? 16 : -16)\n    const attackers = [currentSquare + 1, currentSquare - 1]\n\n    if (\n      this._board[startSquare] !== null ||\n      this._board[this._epSquare] !== null ||\n      this._board[currentSquare]?.color !== swapColor(this._turn) ||\n      this._board[currentSquare]?.type !== PAWN\n    ) {\n      this._epSquare = EMPTY\n      return\n    }\n\n    const canCapture = (square: number) =>\n      !(square & 0x88) &&\n      this._board[square]?.color === this._turn &&\n      this._board[square]?.type === PAWN\n\n    if (!attackers.some(canCapture)) {\n      this._epSquare = EMPTY\n    }\n  }\n\n  private _attacked(color: Color, square: number) {\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      // did we run off the end of the board\n      if (i & 0x88) {\n        i += 7\n        continue\n      }\n\n      // if empty square or wrong color\n      if (this._board[i] === undefined || this._board[i].color !== color) {\n        continue\n      }\n\n      const piece = this._board[i]\n      const difference = i - square\n\n      // skip - to/from square are the same\n      if (difference === 0) {\n        continue\n      }\n\n      const index = difference + 119\n\n      if (ATTACKS[index] & PIECE_MASKS[piece.type]) {\n        if (piece.type === PAWN) {\n          if (difference > 0) {\n            if (piece.color === WHITE) return true\n          } else {\n            if (piece.color === BLACK) return true\n          }\n          continue\n        }\n\n        // if the piece is a knight or a king\n        if (piece.type === 'n' || piece.type === 'k') return true\n\n        const offset = RAYS[index]\n        let j = i + offset\n\n        let blocked = false\n        while (j !== square) {\n          if (this._board[j] != null) {\n            blocked = true\n            break\n          }\n          j += offset\n        }\n\n        if (!blocked) return true\n      }\n    }\n\n    return false\n  }\n\n  private _isKingAttacked(color: Color) {\n    const square = this._kings[color]\n    return square === -1 ? false : this._attacked(swapColor(color), square)\n  }\n\n  isAttacked(square: Square, attackedBy: Color) {\n    return this._attacked(attackedBy, Ox88[square])\n  }\n\n  isCheck() {\n    return this._isKingAttacked(this._turn)\n  }\n\n  inCheck() {\n    return this.isCheck()\n  }\n\n  isCheckmate() {\n    return this.isCheck() && this._moves().length === 0\n  }\n\n  isStalemate() {\n    return !this.isCheck() && this._moves().length === 0\n  }\n\n  isInsufficientMaterial() {\n    /*\n     * k.b. vs k.b. (of opposite colors) with mate in 1:\n     * 8/8/8/8/1b6/8/B1k5/K7 b - - 0 1\n     *\n     * k.b. vs k.n. with mate in 1:\n     * 8/8/8/8/1n6/8/B7/K1k5 b - - 2 1\n     */\n    const pieces: Record<PieceSymbol, number> = {\n      b: 0,\n      n: 0,\n      r: 0,\n      q: 0,\n      k: 0,\n      p: 0,\n    }\n    const bishops = []\n    let numPieces = 0\n    let squareColor = 0\n\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      squareColor = (squareColor + 1) % 2\n      if (i & 0x88) {\n        i += 7\n        continue\n      }\n\n      const piece = this._board[i]\n      if (piece) {\n        pieces[piece.type] = piece.type in pieces ? pieces[piece.type] + 1 : 1\n        if (piece.type === BISHOP) {\n          bishops.push(squareColor)\n        }\n        numPieces++\n      }\n    }\n\n    // k vs. k\n    if (numPieces === 2) {\n      return true\n    } else if (\n      // k vs. kn .... or .... k vs. kb\n      numPieces === 3 &&\n      (pieces[BISHOP] === 1 || pieces[KNIGHT] === 1)\n    ) {\n      return true\n    } else if (numPieces === pieces[BISHOP] + 2) {\n      // kb vs. kb where any number of bishops are all on the same color\n      let sum = 0\n      const len = bishops.length\n      for (let i = 0; i < len; i++) {\n        sum += bishops[i]\n      }\n      if (sum === 0 || sum === len) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  private _getRepetitionCount() {\n    return this._positionCounts[this.fen()]\n  }\n\n  isThreefoldRepetition(): boolean {\n    return this._getRepetitionCount() >= 3\n  }\n\n  isDraw() {\n    return (\n      this._halfMoves >= 100 || // 50 moves per side = 100 half moves\n      this.isStalemate() ||\n      this.isInsufficientMaterial() ||\n      this.isThreefoldRepetition()\n    )\n  }\n\n  isGameOver() {\n    return this.isCheckmate() || this.isStalemate() || this.isDraw()\n  }\n\n  moves(): string[]\n  moves({ square }: { square: Square }): string[]\n  moves({ piece }: { piece: PieceSymbol }): string[]\n\n  moves({ square, piece }: { square: Square; piece: PieceSymbol }): string[]\n\n  moves({ verbose, square }: { verbose: true; square?: Square }): Move[]\n  moves({ verbose, square }: { verbose: false; square?: Square }): string[]\n  moves({\n    verbose,\n    square,\n  }: {\n    verbose?: boolean\n    square?: Square\n  }): string[] | Move[]\n\n  moves({ verbose, piece }: { verbose: true; piece?: PieceSymbol }): Move[]\n  moves({ verbose, piece }: { verbose: false; piece?: PieceSymbol }): string[]\n  moves({\n    verbose,\n    piece,\n  }: {\n    verbose?: boolean\n    piece?: PieceSymbol\n  }): string[] | Move[]\n\n  moves({\n    verbose,\n    square,\n    piece,\n  }: {\n    verbose: true\n    square?: Square\n    piece?: PieceSymbol\n  }): Move[]\n  moves({\n    verbose,\n    square,\n    piece,\n  }: {\n    verbose: false\n    square?: Square\n    piece?: PieceSymbol\n  }): string[]\n  moves({\n    verbose,\n    square,\n    piece,\n  }: {\n    verbose?: boolean\n    square?: Square\n    piece?: PieceSymbol\n  }): string[] | Move[]\n\n  moves({ square, piece }: { square?: Square; piece?: PieceSymbol }): Move[]\n\n  moves({\n    verbose = false,\n    square = undefined,\n    piece = undefined,\n  }: { verbose?: boolean; square?: Square; piece?: PieceSymbol } = {}) {\n    const moves = this._moves({ square, piece })\n\n    if (verbose) {\n      return moves.map((move) => this._makePretty(move))\n    } else {\n      return moves.map((move) => this._moveToSan(move, moves))\n    }\n  }\n\n  private _moves({\n    legal = true,\n    piece = undefined,\n    square = undefined,\n  }: {\n    legal?: boolean\n    piece?: PieceSymbol\n    square?: Square\n  } = {}) {\n    const forSquare = square ? (square.toLowerCase() as Square) : undefined\n    const forPiece = piece?.toLowerCase()\n\n    const moves: InternalMove[] = []\n    const us = this._turn\n    const them = swapColor(us)\n\n    let firstSquare = Ox88.a8\n    let lastSquare = Ox88.h1\n    let singleSquare = false\n\n    // are we generating moves for a single square?\n    if (forSquare) {\n      // illegal square, return empty moves\n      if (!(forSquare in Ox88)) {\n        return []\n      } else {\n        firstSquare = lastSquare = Ox88[forSquare]\n        singleSquare = true\n      }\n    }\n\n    for (let from = firstSquare; from <= lastSquare; from++) {\n      // did we run off the end of the board\n      if (from & 0x88) {\n        from += 7\n        continue\n      }\n\n      // empty square or opponent, skip\n      if (!this._board[from] || this._board[from].color === them) {\n        continue\n      }\n      const { type } = this._board[from]\n\n      let to: number\n      if (type === PAWN) {\n        if (forPiece && forPiece !== type) continue\n\n        // single square, non-capturing\n        to = from + PAWN_OFFSETS[us][0]\n        if (!this._board[to]) {\n          addMove(moves, us, from, to, PAWN)\n\n          // double square\n          to = from + PAWN_OFFSETS[us][1]\n          if (SECOND_RANK[us] === rank(from) && !this._board[to]) {\n            addMove(moves, us, from, to, PAWN, undefined, BITS.BIG_PAWN)\n          }\n        }\n\n        // pawn captures\n        for (let j = 2; j < 4; j++) {\n          to = from + PAWN_OFFSETS[us][j]\n          if (to & 0x88) continue\n\n          if (this._board[to]?.color === them) {\n            addMove(\n              moves,\n              us,\n              from,\n              to,\n              PAWN,\n              this._board[to].type,\n              BITS.CAPTURE,\n            )\n          } else if (to === this._epSquare) {\n            addMove(moves, us, from, to, PAWN, PAWN, BITS.EP_CAPTURE)\n          }\n        }\n      } else {\n        if (forPiece && forPiece !== type) continue\n\n        for (let j = 0, len = PIECE_OFFSETS[type].length; j < len; j++) {\n          const offset = PIECE_OFFSETS[type][j]\n          to = from\n\n          while (true) {\n            to += offset\n            if (to & 0x88) break\n\n            if (!this._board[to]) {\n              addMove(moves, us, from, to, type)\n            } else {\n              // own color, stop loop\n              if (this._board[to].color === us) break\n\n              addMove(\n                moves,\n                us,\n                from,\n                to,\n                type,\n                this._board[to].type,\n                BITS.CAPTURE,\n              )\n              break\n            }\n\n            /* break, if knight or king */\n            if (type === KNIGHT || type === KING) break\n          }\n        }\n      }\n    }\n\n    /*\n     * check for castling if we're:\n     *   a) generating all moves, or\n     *   b) doing single square move generation on the king's square\n     */\n\n    if (forPiece === undefined || forPiece === KING) {\n      if (!singleSquare || lastSquare === this._kings[us]) {\n        // king-side castling\n        if (this._castling[us] & BITS.KSIDE_CASTLE) {\n          const castlingFrom = this._kings[us]\n          const castlingTo = castlingFrom + 2\n\n          if (\n            !this._board[castlingFrom + 1] &&\n            !this._board[castlingTo] &&\n            !this._attacked(them, this._kings[us]) &&\n            !this._attacked(them, castlingFrom + 1) &&\n            !this._attacked(them, castlingTo)\n          ) {\n            addMove(\n              moves,\n              us,\n              this._kings[us],\n              castlingTo,\n              KING,\n              undefined,\n              BITS.KSIDE_CASTLE,\n            )\n          }\n        }\n\n        // queen-side castling\n        if (this._castling[us] & BITS.QSIDE_CASTLE) {\n          const castlingFrom = this._kings[us]\n          const castlingTo = castlingFrom - 2\n\n          if (\n            !this._board[castlingFrom - 1] &&\n            !this._board[castlingFrom - 2] &&\n            !this._board[castlingFrom - 3] &&\n            !this._attacked(them, this._kings[us]) &&\n            !this._attacked(them, castlingFrom - 1) &&\n            !this._attacked(them, castlingTo)\n          ) {\n            addMove(\n              moves,\n              us,\n              this._kings[us],\n              castlingTo,\n              KING,\n              undefined,\n              BITS.QSIDE_CASTLE,\n            )\n          }\n        }\n      }\n    }\n\n    /*\n     * return all pseudo-legal moves (this includes moves that allow the king\n     * to be captured)\n     */\n    if (!legal || this._kings[us] === -1) {\n      return moves\n    }\n\n    // filter out illegal moves\n    const legalMoves = []\n\n    for (let i = 0, len = moves.length; i < len; i++) {\n      this._makeMove(moves[i])\n      if (!this._isKingAttacked(us)) {\n        legalMoves.push(moves[i])\n      }\n      this._undoMove()\n    }\n\n    return legalMoves\n  }\n\n  move(\n    move: string | { from: string; to: string; promotion?: string },\n    { strict = false }: { strict?: boolean } = {},\n  ) {\n    /*\n     * The move function can be called with in the following parameters:\n     *\n     * .move('Nxb7')       <- argument is a case-sensitive SAN string\n     *\n     * .move({ from: 'h7', <- argument is a move object\n     *         to :'h8',\n     *         promotion: 'q' })\n     *\n     *\n     * An optional strict argument may be supplied to tell chess.js to\n     * strictly follow the SAN specification.\n     */\n\n    let moveObj = null\n\n    if (typeof move === 'string') {\n      moveObj = this._moveFromSan(move, strict)\n    } else if (typeof move === 'object') {\n      const moves = this._moves()\n\n      // convert the pretty move object to an ugly move object\n      for (let i = 0, len = moves.length; i < len; i++) {\n        if (\n          move.from === algebraic(moves[i].from) &&\n          move.to === algebraic(moves[i].to) &&\n          (!('promotion' in moves[i]) || move.promotion === moves[i].promotion)\n        ) {\n          moveObj = moves[i]\n          break\n        }\n      }\n    }\n\n    // failed to find move\n    if (!moveObj) {\n      if (typeof move === 'string') {\n        throw new Error(`Invalid move: ${move}`)\n      } else {\n        throw new Error(`Invalid move: ${JSON.stringify(move)}`)\n      }\n    }\n\n    /*\n     * need to make a copy of move because we can't generate SAN after the move\n     * is made\n     */\n    const prettyMove = this._makePretty(moveObj)\n\n    this._makeMove(moveObj)\n    this._positionCounts[prettyMove.after]++\n    return prettyMove\n  }\n\n  private _push(move: InternalMove) {\n    this._history.push({\n      move,\n      kings: { b: this._kings.b, w: this._kings.w },\n      turn: this._turn,\n      castling: { b: this._castling.b, w: this._castling.w },\n      epSquare: this._epSquare,\n      halfMoves: this._halfMoves,\n      moveNumber: this._moveNumber,\n    })\n  }\n\n  private _makeMove(move: InternalMove) {\n    const us = this._turn\n    const them = swapColor(us)\n    this._push(move)\n\n    this._board[move.to] = this._board[move.from]\n    delete this._board[move.from]\n\n    // if ep capture, remove the captured pawn\n    if (move.flags & BITS.EP_CAPTURE) {\n      if (this._turn === BLACK) {\n        delete this._board[move.to - 16]\n      } else {\n        delete this._board[move.to + 16]\n      }\n    }\n\n    // if pawn promotion, replace with new piece\n    if (move.promotion) {\n      this._board[move.to] = { type: move.promotion, color: us }\n    }\n\n    // if we moved the king\n    if (this._board[move.to].type === KING) {\n      this._kings[us] = move.to\n\n      // if we castled, move the rook next to the king\n      if (move.flags & BITS.KSIDE_CASTLE) {\n        const castlingTo = move.to - 1\n        const castlingFrom = move.to + 1\n        this._board[castlingTo] = this._board[castlingFrom]\n        delete this._board[castlingFrom]\n      } else if (move.flags & BITS.QSIDE_CASTLE) {\n        const castlingTo = move.to + 1\n        const castlingFrom = move.to - 2\n        this._board[castlingTo] = this._board[castlingFrom]\n        delete this._board[castlingFrom]\n      }\n\n      // turn off castling\n      this._castling[us] = 0\n    }\n\n    // turn off castling if we move a rook\n    if (this._castling[us]) {\n      for (let i = 0, len = ROOKS[us].length; i < len; i++) {\n        if (\n          move.from === ROOKS[us][i].square &&\n          this._castling[us] & ROOKS[us][i].flag\n        ) {\n          this._castling[us] ^= ROOKS[us][i].flag\n          break\n        }\n      }\n    }\n\n    // turn off castling if we capture a rook\n    if (this._castling[them]) {\n      for (let i = 0, len = ROOKS[them].length; i < len; i++) {\n        if (\n          move.to === ROOKS[them][i].square &&\n          this._castling[them] & ROOKS[them][i].flag\n        ) {\n          this._castling[them] ^= ROOKS[them][i].flag\n          break\n        }\n      }\n    }\n\n    // if big pawn move, update the en passant square\n    if (move.flags & BITS.BIG_PAWN) {\n      if (us === BLACK) {\n        this._epSquare = move.to - 16\n      } else {\n        this._epSquare = move.to + 16\n      }\n    } else {\n      this._epSquare = EMPTY\n    }\n\n    // reset the 50 move counter if a pawn is moved or a piece is captured\n    if (move.piece === PAWN) {\n      this._halfMoves = 0\n    } else if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n      this._halfMoves = 0\n    } else {\n      this._halfMoves++\n    }\n\n    if (us === BLACK) {\n      this._moveNumber++\n    }\n\n    this._turn = them\n  }\n\n  undo() {\n    const move = this._undoMove()\n    if (move) {\n      const prettyMove = this._makePretty(move)\n      this._positionCounts[prettyMove.after]--\n      return prettyMove\n    }\n    return null\n  }\n\n  private _undoMove() {\n    const old = this._history.pop()\n    if (old === undefined) {\n      return null\n    }\n\n    const move = old.move\n\n    this._kings = old.kings\n    this._turn = old.turn\n    this._castling = old.castling\n    this._epSquare = old.epSquare\n    this._halfMoves = old.halfMoves\n    this._moveNumber = old.moveNumber\n\n    const us = this._turn\n    const them = swapColor(us)\n\n    this._board[move.from] = this._board[move.to]\n    this._board[move.from].type = move.piece // to undo any promotions\n    delete this._board[move.to]\n\n    if (move.captured) {\n      if (move.flags & BITS.EP_CAPTURE) {\n        // en passant capture\n        let index: number\n        if (us === BLACK) {\n          index = move.to - 16\n        } else {\n          index = move.to + 16\n        }\n        this._board[index] = { type: PAWN, color: them }\n      } else {\n        // regular capture\n        this._board[move.to] = { type: move.captured, color: them }\n      }\n    }\n\n    if (move.flags & (BITS.KSIDE_CASTLE | BITS.QSIDE_CASTLE)) {\n      let castlingTo: number, castlingFrom: number\n      if (move.flags & BITS.KSIDE_CASTLE) {\n        castlingTo = move.to + 1\n        castlingFrom = move.to - 1\n      } else {\n        castlingTo = move.to - 2\n        castlingFrom = move.to + 1\n      }\n\n      this._board[castlingTo] = this._board[castlingFrom]\n      delete this._board[castlingFrom]\n    }\n\n    return move\n  }\n\n  pgn({\n    newline = '\\n',\n    maxWidth = 0,\n  }: { newline?: string; maxWidth?: number } = {}) {\n    /*\n     * using the specification from http://www.chessclub.com/help/PGN-spec\n     * example for html usage: .pgn({ max_width: 72, newline_char: \"<br />\" })\n     */\n\n    const result: string[] = []\n    let headerExists = false\n\n    /* add the PGN header information */\n    for (const i in this._header) {\n      /*\n       * TODO: order of enumerated properties in header object is not\n       * guaranteed, see ECMA-262 spec (section 12.6.4)\n       */\n      result.push('[' + i + ' \"' + this._header[i] + '\"]' + newline)\n      headerExists = true\n    }\n\n    if (headerExists && this._history.length) {\n      result.push(newline)\n    }\n\n    const appendComment = (moveString: string) => {\n      const comment = this._comments[this.fen()]\n      if (typeof comment !== 'undefined') {\n        const delimiter = moveString.length > 0 ? ' ' : ''\n        moveString = `${moveString}${delimiter}{${comment}}`\n      }\n      return moveString\n    }\n\n    // pop all of history onto reversed_history\n    const reversedHistory = []\n    while (this._history.length > 0) {\n      reversedHistory.push(this._undoMove())\n    }\n\n    const moves = []\n    let moveString = ''\n\n    // special case of a commented starting position with no moves\n    if (reversedHistory.length === 0) {\n      moves.push(appendComment(''))\n    }\n\n    // build the list of moves.  a move_string looks like: \"3. e3 e6\"\n    while (reversedHistory.length > 0) {\n      moveString = appendComment(moveString)\n      const move = reversedHistory.pop()\n\n      // make TypeScript stop complaining about move being undefined\n      if (!move) {\n        break\n      }\n\n      // if the position started with black to move, start PGN with #. ...\n      if (!this._history.length && move.color === 'b') {\n        const prefix = `${this._moveNumber}. ...`\n        // is there a comment preceding the first move?\n        moveString = moveString ? `${moveString} ${prefix}` : prefix\n      } else if (move.color === 'w') {\n        // store the previous generated move_string if we have one\n        if (moveString.length) {\n          moves.push(moveString)\n        }\n        moveString = this._moveNumber + '.'\n      }\n\n      moveString =\n        moveString + ' ' + this._moveToSan(move, this._moves({ legal: true }))\n      this._makeMove(move)\n    }\n\n    // are there any other leftover moves?\n    if (moveString.length) {\n      moves.push(appendComment(moveString))\n    }\n\n    // is there a result?\n    if (typeof this._header.Result !== 'undefined') {\n      moves.push(this._header.Result)\n    }\n\n    /*\n     * history should be back to what it was before we started generating PGN,\n     * so join together moves\n     */\n    if (maxWidth === 0) {\n      return result.join('') + moves.join(' ')\n    }\n\n    // TODO (jah): huh?\n    const strip = function () {\n      if (result.length > 0 && result[result.length - 1] === ' ') {\n        result.pop()\n        return true\n      }\n      return false\n    }\n\n    // NB: this does not preserve comment whitespace.\n    const wrapComment = function (width: number, move: string) {\n      for (const token of move.split(' ')) {\n        if (!token) {\n          continue\n        }\n        if (width + token.length > maxWidth) {\n          while (strip()) {\n            width--\n          }\n          result.push(newline)\n          width = 0\n        }\n        result.push(token)\n        width += token.length\n        result.push(' ')\n        width++\n      }\n      if (strip()) {\n        width--\n      }\n      return width\n    }\n\n    // wrap the PGN output at max_width\n    let currentWidth = 0\n    for (let i = 0; i < moves.length; i++) {\n      if (currentWidth + moves[i].length > maxWidth) {\n        if (moves[i].includes('{')) {\n          currentWidth = wrapComment(currentWidth, moves[i])\n          continue\n        }\n      }\n      // if the current move will push past max_width\n      if (currentWidth + moves[i].length > maxWidth && i !== 0) {\n        // don't end the line with whitespace\n        if (result[result.length - 1] === ' ') {\n          result.pop()\n        }\n\n        result.push(newline)\n        currentWidth = 0\n      } else if (i !== 0) {\n        result.push(' ')\n        currentWidth++\n      }\n      result.push(moves[i])\n      currentWidth += moves[i].length\n    }\n\n    return result.join('')\n  }\n\n  header(...args: string[]) {\n    for (let i = 0; i < args.length; i += 2) {\n      if (typeof args[i] === 'string' && typeof args[i + 1] === 'string') {\n        this._header[args[i]] = args[i + 1]\n      }\n    }\n    return this._header\n  }\n\n  loadPgn(\n    pgn: string,\n    {\n      strict = false,\n      newlineChar = '\\r?\\n',\n    }: { strict?: boolean; newlineChar?: string } = {},\n  ) {\n    function mask(str: string): string {\n      return str.replace(/\\\\/g, '\\\\')\n    }\n\n    function parsePgnHeader(header: string): { [key: string]: string } {\n      const headerObj: Record<string, string> = {}\n      const headers = header.split(new RegExp(mask(newlineChar)))\n      let key = ''\n      let value = ''\n\n      for (let i = 0; i < headers.length; i++) {\n        const regex = /^\\s*\\[\\s*([A-Za-z]+)\\s*\"(.*)\"\\s*\\]\\s*$/\n        key = headers[i].replace(regex, '$1')\n        value = headers[i].replace(regex, '$2')\n        if (key.trim().length > 0) {\n          headerObj[key] = value\n        }\n      }\n\n      return headerObj\n    }\n\n    // strip whitespace from head/tail of PGN block\n    pgn = pgn.trim()\n\n    /*\n     * RegExp to split header. Takes advantage of the fact that header and movetext\n     * will always have a blank line between them (ie, two newline_char's). Handles\n     * case where movetext is empty by matching newlineChar until end of string is\n     * matched - effectively trimming from the end extra newlineChar.\n     *\n     * With default newline_char, will equal:\n     * /^(\\[((?:\\r?\\n)|.)*\\])((?:\\s*\\r?\\n){2}|(?:\\s*\\r?\\n)*$)/\n     */\n    const headerRegex = new RegExp(\n      '^(\\\\[((?:' +\n        mask(newlineChar) +\n        ')|.)*\\\\])' +\n        '((?:\\\\s*' +\n        mask(newlineChar) +\n        '){2}|(?:\\\\s*' +\n        mask(newlineChar) +\n        ')*$)',\n    )\n\n    // If no header given, begin with moves.\n    const headerRegexResults = headerRegex.exec(pgn)\n    const headerString = headerRegexResults\n      ? headerRegexResults.length >= 2\n        ? headerRegexResults[1]\n        : ''\n      : ''\n\n    // Put the board in the starting position\n    this.reset()\n\n    // parse PGN header\n    const headers = parsePgnHeader(headerString)\n    let fen = ''\n\n    for (const key in headers) {\n      // check to see user is including fen (possibly with wrong tag case)\n      if (key.toLowerCase() === 'fen') {\n        fen = headers[key]\n      }\n\n      this.header(key, headers[key])\n    }\n\n    /*\n     * the permissive parser should attempt to load a fen tag, even if it's the\n     * wrong case and doesn't include a corresponding [SetUp \"1\"] tag\n     */\n    if (!strict) {\n      if (fen) {\n        this.load(fen, { preserveHeaders: true })\n      }\n    } else {\n      /*\n       * strict parser - load the starting position indicated by [Setup '1']\n       * and [FEN position]\n       */\n      if (headers['SetUp'] === '1') {\n        if (!('FEN' in headers)) {\n          throw new Error(\n            'Invalid PGN: FEN tag must be supplied with SetUp tag',\n          )\n        }\n        // don't clear the headers when loading\n        this.load(headers['FEN'], { preserveHeaders: true })\n      }\n    }\n\n    /*\n     * NB: the regexes below that delete move numbers, recursive annotations,\n     * and numeric annotation glyphs may also match text in comments. To\n     * prevent this, we transform comments by hex-encoding them in place and\n     * decoding them again after the other tokens have been deleted.\n     *\n     * While the spec states that PGN files should be ASCII encoded, we use\n     * {en,de}codeURIComponent here to support arbitrary UTF8 as a convenience\n     * for modern users\n     */\n\n    function toHex(s: string): string {\n      return Array.from(s)\n        .map(function (c) {\n          /*\n           * encodeURI doesn't transform most ASCII characters, so we handle\n           * these ourselves\n           */\n          return c.charCodeAt(0) < 128\n            ? c.charCodeAt(0).toString(16)\n            : encodeURIComponent(c).replace(/%/g, '').toLowerCase()\n        })\n        .join('')\n    }\n\n    function fromHex(s: string): string {\n      return s.length == 0\n        ? ''\n        : decodeURIComponent('%' + (s.match(/.{1,2}/g) || []).join('%'))\n    }\n\n    const encodeComment = function (s: string) {\n      s = s.replace(new RegExp(mask(newlineChar), 'g'), ' ')\n      return `{${toHex(s.slice(1, s.length - 1))}}`\n    }\n\n    const decodeComment = function (s: string) {\n      if (s.startsWith('{') && s.endsWith('}')) {\n        return fromHex(s.slice(1, s.length - 1))\n      }\n    }\n\n    // delete header to get the moves\n    let ms = pgn\n      .replace(headerString, '')\n      .replace(\n        // encode comments so they don't get deleted below\n        new RegExp(`({[^}]*})+?|;([^${mask(newlineChar)}]*)`, 'g'),\n        function (_match, bracket, semicolon) {\n          return bracket !== undefined\n            ? encodeComment(bracket)\n            : ' ' + encodeComment(`{${semicolon.slice(1)}}`)\n        },\n      )\n      .replace(new RegExp(mask(newlineChar), 'g'), ' ')\n\n    // delete recursive annotation variations\n    const ravRegex = /(\\([^()]+\\))+?/g\n    while (ravRegex.test(ms)) {\n      ms = ms.replace(ravRegex, '')\n    }\n\n    // delete move numbers\n    ms = ms.replace(/\\d+\\.(\\.\\.)?/g, '')\n\n    // delete ... indicating black to move\n    ms = ms.replace(/\\.\\.\\./g, '')\n\n    /* delete numeric annotation glyphs */\n    ms = ms.replace(/\\$\\d+/g, '')\n\n    // trim and get array of moves\n    let moves = ms.trim().split(new RegExp(/\\s+/))\n\n    // delete empty entries\n    moves = moves.filter((move) => move !== '')\n\n    let result = ''\n\n    for (let halfMove = 0; halfMove < moves.length; halfMove++) {\n      const comment = decodeComment(moves[halfMove])\n      if (comment !== undefined) {\n        this._comments[this.fen()] = comment\n        continue\n      }\n\n      const move = this._moveFromSan(moves[halfMove], strict)\n\n      // invalid move\n      if (move == null) {\n        // was the move an end of game marker\n        if (TERMINATION_MARKERS.indexOf(moves[halfMove]) > -1) {\n          result = moves[halfMove]\n        } else {\n          throw new Error(`Invalid move in PGN: ${moves[halfMove]}`)\n        }\n      } else {\n        // reset the end of game marker if making a valid move\n        result = ''\n        this._makeMove(move)\n        this._positionCounts[this.fen()]++\n      }\n    }\n\n    /*\n     * Per section 8.2.6 of the PGN spec, the Result tag pair must match match\n     * the termination marker. Only do this when headers are present, but the\n     * result tag is missing\n     */\n\n    if (result && Object.keys(this._header).length && !this._header['Result']) {\n      this.header('Result', result)\n    }\n  }\n\n  /*\n   * Convert a move from 0x88 coordinates to Standard Algebraic Notation\n   * (SAN)\n   *\n   * @param {boolean} strict Use the strict SAN parser. It will throw errors\n   * on overly disambiguated moves (see below):\n   *\n   * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4\n   * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned\n   * 4. ... Ne7 is technically the valid SAN\n   */\n\n  private _moveToSan(move: InternalMove, moves: InternalMove[]) {\n    let output = ''\n\n    if (move.flags & BITS.KSIDE_CASTLE) {\n      output = 'O-O'\n    } else if (move.flags & BITS.QSIDE_CASTLE) {\n      output = 'O-O-O'\n    } else {\n      if (move.piece !== PAWN) {\n        const disambiguator = getDisambiguator(move, moves)\n        output += move.piece.toUpperCase() + disambiguator\n      }\n\n      if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n        if (move.piece === PAWN) {\n          output += algebraic(move.from)[0]\n        }\n        output += 'x'\n      }\n\n      output += algebraic(move.to)\n\n      if (move.promotion) {\n        output += '=' + move.promotion.toUpperCase()\n      }\n    }\n\n    this._makeMove(move)\n    if (this.isCheck()) {\n      if (this.isCheckmate()) {\n        output += '#'\n      } else {\n        output += '+'\n      }\n    }\n    this._undoMove()\n\n    return output\n  }\n\n  // convert a move from Standard Algebraic Notation (SAN) to 0x88 coordinates\n  private _moveFromSan(move: string, strict = false): InternalMove | null {\n    // strip off any move decorations: e.g Nf3+?! becomes Nf3\n    const cleanMove = strippedSan(move)\n\n    let pieceType = inferPieceType(cleanMove)\n    let moves = this._moves({ legal: true, piece: pieceType })\n\n    // strict parser\n    for (let i = 0, len = moves.length; i < len; i++) {\n      if (cleanMove === strippedSan(this._moveToSan(moves[i], moves))) {\n        return moves[i]\n      }\n    }\n\n    // the strict parser failed\n    if (strict) {\n      return null\n    }\n\n    let piece = undefined\n    let matches = undefined\n    let from = undefined\n    let to = undefined\n    let promotion = undefined\n\n    /*\n     * The default permissive (non-strict) parser allows the user to parse\n     * non-standard chess notations. This parser is only run after the strict\n     * Standard Algebraic Notation (SAN) parser has failed.\n     *\n     * When running the permissive parser, we'll run a regex to grab the piece, the\n     * to/from square, and an optional promotion piece. This regex will\n     * parse common non-standard notation like: Pe2-e4, Rc1c4, Qf3xf7,\n     * f7f8q, b1c3\n     *\n     * NOTE: Some positions and moves may be ambiguous when using the permissive\n     * parser. For example, in this position: 6k1/8/8/B7/8/8/8/BN4K1 w - - 0 1,\n     * the move b1c3 may be interpreted as Nc3 or B1c3 (a disambiguated bishop\n     * move). In these cases, the permissive parser will default to the most\n     * basic interpretation (which is b1c3 parsing to Nc3).\n     */\n\n    let overlyDisambiguated = false\n\n    matches = cleanMove.match(\n      /([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/,\n      //     piece         from              to       promotion\n    )\n\n    if (matches) {\n      piece = matches[1]\n      from = matches[2] as Square\n      to = matches[3] as Square\n      promotion = matches[4]\n\n      if (from.length == 1) {\n        overlyDisambiguated = true\n      }\n    } else {\n      /*\n       * The [a-h]?[1-8]? portion of the regex below handles moves that may be\n       * overly disambiguated (e.g. Nge7 is unnecessary and non-standard when\n       * there is one legal knight move to e7). In this case, the value of\n       * 'from' variable will be a rank or file, not a square.\n       */\n\n      matches = cleanMove.match(\n        /([pnbrqkPNBRQK])?([a-h]?[1-8]?)x?-?([a-h][1-8])([qrbnQRBN])?/,\n      )\n\n      if (matches) {\n        piece = matches[1]\n        from = matches[2] as Square\n        to = matches[3] as Square\n        promotion = matches[4]\n\n        if (from.length == 1) {\n          overlyDisambiguated = true\n        }\n      }\n    }\n\n    pieceType = inferPieceType(cleanMove)\n    moves = this._moves({\n      legal: true,\n      piece: piece ? (piece as PieceSymbol) : pieceType,\n    })\n\n    if (!to) {\n      return null\n    }\n\n    for (let i = 0, len = moves.length; i < len; i++) {\n      if (!from) {\n        // if there is no from square, it could be just 'x' missing from a capture\n        if (\n          cleanMove ===\n          strippedSan(this._moveToSan(moves[i], moves)).replace('x', '')\n        ) {\n          return moves[i]\n        }\n        // hand-compare move properties with the results from our permissive regex\n      } else if (\n        (!piece || piece.toLowerCase() == moves[i].piece) &&\n        Ox88[from] == moves[i].from &&\n        Ox88[to] == moves[i].to &&\n        (!promotion || promotion.toLowerCase() == moves[i].promotion)\n      ) {\n        return moves[i]\n      } else if (overlyDisambiguated) {\n        /*\n         * SPECIAL CASE: we parsed a move string that may have an unneeded\n         * rank/file disambiguator (e.g. Nge7).  The 'from' variable will\n         */\n\n        const square = algebraic(moves[i].from)\n        if (\n          (!piece || piece.toLowerCase() == moves[i].piece) &&\n          Ox88[to] == moves[i].to &&\n          (from == square[0] || from == square[1]) &&\n          (!promotion || promotion.toLowerCase() == moves[i].promotion)\n        ) {\n          return moves[i]\n        }\n      }\n    }\n\n    return null\n  }\n\n  ascii() {\n    let s = '   +------------------------+\\n'\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      // display the rank\n      if (file(i) === 0) {\n        s += ' ' + '87654321'[rank(i)] + ' |'\n      }\n\n      if (this._board[i]) {\n        const piece = this._board[i].type\n        const color = this._board[i].color\n        const symbol =\n          color === WHITE ? piece.toUpperCase() : piece.toLowerCase()\n        s += ' ' + symbol + ' '\n      } else {\n        s += ' . '\n      }\n\n      if ((i + 1) & 0x88) {\n        s += '|\\n'\n        i += 8\n      }\n    }\n    s += '   +------------------------+\\n'\n    s += '     a  b  c  d  e  f  g  h'\n\n    return s\n  }\n\n  perft(depth: number) {\n    const moves = this._moves({ legal: false })\n    let nodes = 0\n    const color = this._turn\n\n    for (let i = 0, len = moves.length; i < len; i++) {\n      this._makeMove(moves[i])\n      if (!this._isKingAttacked(color)) {\n        if (depth - 1 > 0) {\n          nodes += this.perft(depth - 1)\n        } else {\n          nodes++\n        }\n      }\n      this._undoMove()\n    }\n\n    return nodes\n  }\n\n  // pretty = external move object\n  private _makePretty(uglyMove: InternalMove): Move {\n    const { color, piece, from, to, flags, captured, promotion } = uglyMove\n\n    let prettyFlags = ''\n\n    for (const flag in BITS) {\n      if (BITS[flag] & flags) {\n        prettyFlags += FLAGS[flag]\n      }\n    }\n\n    const fromAlgebraic = algebraic(from)\n    const toAlgebraic = algebraic(to)\n\n    const move: Move = {\n      color,\n      piece,\n      from: fromAlgebraic,\n      to: toAlgebraic,\n      san: this._moveToSan(uglyMove, this._moves({ legal: true })),\n      flags: prettyFlags,\n      lan: fromAlgebraic + toAlgebraic,\n      before: this.fen(),\n      after: '',\n    }\n\n    // generate the FEN for the 'after' key\n    this._makeMove(uglyMove)\n    move.after = this.fen()\n    this._undoMove()\n\n    if (captured) {\n      move.captured = captured\n    }\n    if (promotion) {\n      move.promotion = promotion\n      move.lan += promotion\n    }\n\n    return move\n  }\n\n  turn() {\n    return this._turn\n  }\n\n  board() {\n    const output = []\n    let row = []\n\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      if (this._board[i] == null) {\n        row.push(null)\n      } else {\n        row.push({\n          square: algebraic(i),\n          type: this._board[i].type,\n          color: this._board[i].color,\n        })\n      }\n      if ((i + 1) & 0x88) {\n        output.push(row)\n        row = []\n        i += 8\n      }\n    }\n\n    return output\n  }\n\n  squareColor(square: Square) {\n    if (square in Ox88) {\n      const sq = Ox88[square]\n      return (rank(sq) + file(sq)) % 2 === 0 ? 'light' : 'dark'\n    }\n\n    return null\n  }\n\n  history(): string[]\n  history({ verbose }: { verbose: true }): Move[]\n  history({ verbose }: { verbose: false }): string[]\n  history({ verbose }: { verbose: boolean }): string[] | Move[]\n  history({ verbose = false }: { verbose?: boolean } = {}) {\n    const reversedHistory = []\n    const moveHistory = []\n\n    while (this._history.length > 0) {\n      reversedHistory.push(this._undoMove())\n    }\n\n    while (true) {\n      const move = reversedHistory.pop()\n      if (!move) {\n        break\n      }\n\n      if (verbose) {\n        moveHistory.push(this._makePretty(move))\n      } else {\n        moveHistory.push(this._moveToSan(move, this._moves()))\n      }\n      this._makeMove(move)\n    }\n\n    return moveHistory\n  }\n\n  private _pruneComments() {\n    const reversedHistory = []\n    const currentComments: Record<string, string> = {}\n\n    const copyComment = (fen: string) => {\n      if (fen in this._comments) {\n        currentComments[fen] = this._comments[fen]\n      }\n    }\n\n    while (this._history.length > 0) {\n      reversedHistory.push(this._undoMove())\n    }\n\n    copyComment(this.fen())\n\n    while (true) {\n      const move = reversedHistory.pop()\n      if (!move) {\n        break\n      }\n      this._makeMove(move)\n      copyComment(this.fen())\n    }\n    this._comments = currentComments\n  }\n\n  getComment() {\n    return this._comments[this.fen()]\n  }\n\n  setComment(comment: string) {\n    this._comments[this.fen()] = comment.replace('{', '[').replace('}', ']')\n  }\n\n  deleteComment() {\n    const comment = this._comments[this.fen()]\n    delete this._comments[this.fen()]\n    return comment\n  }\n\n  getComments() {\n    this._pruneComments()\n    return Object.keys(this._comments).map((fen: string) => {\n      return { fen: fen, comment: this._comments[fen] }\n    })\n  }\n\n  deleteComments() {\n    this._pruneComments()\n    return Object.keys(this._comments).map((fen) => {\n      const comment = this._comments[fen]\n      delete this._comments[fen]\n      return { fen: fen, comment: comment }\n    })\n  }\n\n  setCastlingRights(\n    color: Color,\n    rights: Partial<Record<typeof KING | typeof QUEEN, boolean>>,\n  ) {\n    for (const side of [KING, QUEEN] as const) {\n      if (rights[side] !== undefined) {\n        if (rights[side]) {\n          this._castling[color] |= SIDES[side]\n        } else {\n          this._castling[color] &= ~SIDES[side]\n        }\n      }\n    }\n\n    this._updateCastlingRights()\n    const result = this.getCastlingRights(color)\n\n    return (\n      (rights[KING] === undefined || rights[KING] === result[KING]) &&\n      (rights[QUEEN] === undefined || rights[QUEEN] === result[QUEEN])\n    )\n  }\n\n  getCastlingRights(color: Color) {\n    return {\n      [KING]: (this._castling[color] & SIDES[KING]) !== 0,\n      [QUEEN]: (this._castling[color] & SIDES[QUEEN]) !== 0,\n    }\n  }\n\n  moveNumber() {\n    return this._moveNumber\n  }\n}\n","import toPropertyKey from \"./toPropertyKey.js\";\nexport default function _defineProperty(obj, key, value) {\n  key = toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}","import _typeof from \"./typeof.js\";\nexport default function toPrimitive(t, r) {\n  if (\"object\" != _typeof(t) || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != _typeof(i)) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}","import _typeof from \"./typeof.js\";\nimport toPrimitive from \"./toPrimitive.js\";\nexport default function toPropertyKey(t) {\n  var i = toPrimitive(t, \"string\");\n  return \"symbol\" == _typeof(i) ? i : String(i);\n}","export default function _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}","/*\n * Dexie.js - a minimalistic wrapper for IndexedDB\n * ===============================================\n *\n * By David Fahlander, david.fahlander@gmail.com\n *\n * Version 3.2.4, Tue May 30 2023\n *\n * https://dexie.org\n *\n * Apache License Version 2.0, January 2004, http://www.apache.org/licenses/\n */\n \nconst _global = typeof globalThis !== 'undefined' ? globalThis :\n    typeof self !== 'undefined' ? self :\n        typeof window !== 'undefined' ? window :\n            global;\n\nconst keys = Object.keys;\nconst isArray = Array.isArray;\nif (typeof Promise !== 'undefined' && !_global.Promise) {\n    _global.Promise = Promise;\n}\nfunction extend(obj, extension) {\n    if (typeof extension !== 'object')\n        return obj;\n    keys(extension).forEach(function (key) {\n        obj[key] = extension[key];\n    });\n    return obj;\n}\nconst getProto = Object.getPrototypeOf;\nconst _hasOwn = {}.hasOwnProperty;\nfunction hasOwn(obj, prop) {\n    return _hasOwn.call(obj, prop);\n}\nfunction props(proto, extension) {\n    if (typeof extension === 'function')\n        extension = extension(getProto(proto));\n    (typeof Reflect === \"undefined\" ? keys : Reflect.ownKeys)(extension).forEach(key => {\n        setProp(proto, key, extension[key]);\n    });\n}\nconst defineProperty = Object.defineProperty;\nfunction setProp(obj, prop, functionOrGetSet, options) {\n    defineProperty(obj, prop, extend(functionOrGetSet && hasOwn(functionOrGetSet, \"get\") && typeof functionOrGetSet.get === 'function' ?\n        { get: functionOrGetSet.get, set: functionOrGetSet.set, configurable: true } :\n        { value: functionOrGetSet, configurable: true, writable: true }, options));\n}\nfunction derive(Child) {\n    return {\n        from: function (Parent) {\n            Child.prototype = Object.create(Parent.prototype);\n            setProp(Child.prototype, \"constructor\", Child);\n            return {\n                extend: props.bind(null, Child.prototype)\n            };\n        }\n    };\n}\nconst getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nfunction getPropertyDescriptor(obj, prop) {\n    const pd = getOwnPropertyDescriptor(obj, prop);\n    let proto;\n    return pd || (proto = getProto(obj)) && getPropertyDescriptor(proto, prop);\n}\nconst _slice = [].slice;\nfunction slice(args, start, end) {\n    return _slice.call(args, start, end);\n}\nfunction override(origFunc, overridedFactory) {\n    return overridedFactory(origFunc);\n}\nfunction assert(b) {\n    if (!b)\n        throw new Error(\"Assertion Failed\");\n}\nfunction asap$1(fn) {\n    if (_global.setImmediate)\n        setImmediate(fn);\n    else\n        setTimeout(fn, 0);\n}\nfunction arrayToObject(array, extractor) {\n    return array.reduce((result, item, i) => {\n        var nameAndValue = extractor(item, i);\n        if (nameAndValue)\n            result[nameAndValue[0]] = nameAndValue[1];\n        return result;\n    }, {});\n}\nfunction tryCatch(fn, onerror, args) {\n    try {\n        fn.apply(null, args);\n    }\n    catch (ex) {\n        onerror && onerror(ex);\n    }\n}\nfunction getByKeyPath(obj, keyPath) {\n    if (hasOwn(obj, keyPath))\n        return obj[keyPath];\n    if (!keyPath)\n        return obj;\n    if (typeof keyPath !== 'string') {\n        var rv = [];\n        for (var i = 0, l = keyPath.length; i < l; ++i) {\n            var val = getByKeyPath(obj, keyPath[i]);\n            rv.push(val);\n        }\n        return rv;\n    }\n    var period = keyPath.indexOf('.');\n    if (period !== -1) {\n        var innerObj = obj[keyPath.substr(0, period)];\n        return innerObj === undefined ? undefined : getByKeyPath(innerObj, keyPath.substr(period + 1));\n    }\n    return undefined;\n}\nfunction setByKeyPath(obj, keyPath, value) {\n    if (!obj || keyPath === undefined)\n        return;\n    if ('isFrozen' in Object && Object.isFrozen(obj))\n        return;\n    if (typeof keyPath !== 'string' && 'length' in keyPath) {\n        assert(typeof value !== 'string' && 'length' in value);\n        for (var i = 0, l = keyPath.length; i < l; ++i) {\n            setByKeyPath(obj, keyPath[i], value[i]);\n        }\n    }\n    else {\n        var period = keyPath.indexOf('.');\n        if (period !== -1) {\n            var currentKeyPath = keyPath.substr(0, period);\n            var remainingKeyPath = keyPath.substr(period + 1);\n            if (remainingKeyPath === \"\")\n                if (value === undefined) {\n                    if (isArray(obj) && !isNaN(parseInt(currentKeyPath)))\n                        obj.splice(currentKeyPath, 1);\n                    else\n                        delete obj[currentKeyPath];\n                }\n                else\n                    obj[currentKeyPath] = value;\n            else {\n                var innerObj = obj[currentKeyPath];\n                if (!innerObj || !hasOwn(obj, currentKeyPath))\n                    innerObj = (obj[currentKeyPath] = {});\n                setByKeyPath(innerObj, remainingKeyPath, value);\n            }\n        }\n        else {\n            if (value === undefined) {\n                if (isArray(obj) && !isNaN(parseInt(keyPath)))\n                    obj.splice(keyPath, 1);\n                else\n                    delete obj[keyPath];\n            }\n            else\n                obj[keyPath] = value;\n        }\n    }\n}\nfunction delByKeyPath(obj, keyPath) {\n    if (typeof keyPath === 'string')\n        setByKeyPath(obj, keyPath, undefined);\n    else if ('length' in keyPath)\n        [].map.call(keyPath, function (kp) {\n            setByKeyPath(obj, kp, undefined);\n        });\n}\nfunction shallowClone(obj) {\n    var rv = {};\n    for (var m in obj) {\n        if (hasOwn(obj, m))\n            rv[m] = obj[m];\n    }\n    return rv;\n}\nconst concat = [].concat;\nfunction flatten(a) {\n    return concat.apply([], a);\n}\nconst intrinsicTypeNames = \"Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey\"\n    .split(',').concat(flatten([8, 16, 32, 64].map(num => [\"Int\", \"Uint\", \"Float\"].map(t => t + num + \"Array\")))).filter(t => _global[t]);\nconst intrinsicTypes = intrinsicTypeNames.map(t => _global[t]);\narrayToObject(intrinsicTypeNames, x => [x, true]);\nlet circularRefs = null;\nfunction deepClone(any) {\n    circularRefs = typeof WeakMap !== 'undefined' && new WeakMap();\n    const rv = innerDeepClone(any);\n    circularRefs = null;\n    return rv;\n}\nfunction innerDeepClone(any) {\n    if (!any || typeof any !== 'object')\n        return any;\n    let rv = circularRefs && circularRefs.get(any);\n    if (rv)\n        return rv;\n    if (isArray(any)) {\n        rv = [];\n        circularRefs && circularRefs.set(any, rv);\n        for (var i = 0, l = any.length; i < l; ++i) {\n            rv.push(innerDeepClone(any[i]));\n        }\n    }\n    else if (intrinsicTypes.indexOf(any.constructor) >= 0) {\n        rv = any;\n    }\n    else {\n        const proto = getProto(any);\n        rv = proto === Object.prototype ? {} : Object.create(proto);\n        circularRefs && circularRefs.set(any, rv);\n        for (var prop in any) {\n            if (hasOwn(any, prop)) {\n                rv[prop] = innerDeepClone(any[prop]);\n            }\n        }\n    }\n    return rv;\n}\nconst { toString } = {};\nfunction toStringTag(o) {\n    return toString.call(o).slice(8, -1);\n}\nconst iteratorSymbol = typeof Symbol !== 'undefined' ?\n    Symbol.iterator :\n    '@@iterator';\nconst getIteratorOf = typeof iteratorSymbol === \"symbol\" ? function (x) {\n    var i;\n    return x != null && (i = x[iteratorSymbol]) && i.apply(x);\n} : function () { return null; };\nconst NO_CHAR_ARRAY = {};\nfunction getArrayOf(arrayLike) {\n    var i, a, x, it;\n    if (arguments.length === 1) {\n        if (isArray(arrayLike))\n            return arrayLike.slice();\n        if (this === NO_CHAR_ARRAY && typeof arrayLike === 'string')\n            return [arrayLike];\n        if ((it = getIteratorOf(arrayLike))) {\n            a = [];\n            while ((x = it.next()), !x.done)\n                a.push(x.value);\n            return a;\n        }\n        if (arrayLike == null)\n            return [arrayLike];\n        i = arrayLike.length;\n        if (typeof i === 'number') {\n            a = new Array(i);\n            while (i--)\n                a[i] = arrayLike[i];\n            return a;\n        }\n        return [arrayLike];\n    }\n    i = arguments.length;\n    a = new Array(i);\n    while (i--)\n        a[i] = arguments[i];\n    return a;\n}\nconst isAsyncFunction = typeof Symbol !== 'undefined'\n    ? (fn) => fn[Symbol.toStringTag] === 'AsyncFunction'\n    : () => false;\n\nvar debug = typeof location !== 'undefined' &&\n    /^(http|https):\\/\\/(localhost|127\\.0\\.0\\.1)/.test(location.href);\nfunction setDebug(value, filter) {\n    debug = value;\n    libraryFilter = filter;\n}\nvar libraryFilter = () => true;\nconst NEEDS_THROW_FOR_STACK = !new Error(\"\").stack;\nfunction getErrorWithStack() {\n    if (NEEDS_THROW_FOR_STACK)\n        try {\n            getErrorWithStack.arguments;\n            throw new Error();\n        }\n        catch (e) {\n            return e;\n        }\n    return new Error();\n}\nfunction prettyStack(exception, numIgnoredFrames) {\n    var stack = exception.stack;\n    if (!stack)\n        return \"\";\n    numIgnoredFrames = (numIgnoredFrames || 0);\n    if (stack.indexOf(exception.name) === 0)\n        numIgnoredFrames += (exception.name + exception.message).split('\\n').length;\n    return stack.split('\\n')\n        .slice(numIgnoredFrames)\n        .filter(libraryFilter)\n        .map(frame => \"\\n\" + frame)\n        .join('');\n}\n\nvar dexieErrorNames = [\n    'Modify',\n    'Bulk',\n    'OpenFailed',\n    'VersionChange',\n    'Schema',\n    'Upgrade',\n    'InvalidTable',\n    'MissingAPI',\n    'NoSuchDatabase',\n    'InvalidArgument',\n    'SubTransaction',\n    'Unsupported',\n    'Internal',\n    'DatabaseClosed',\n    'PrematureCommit',\n    'ForeignAwait'\n];\nvar idbDomErrorNames = [\n    'Unknown',\n    'Constraint',\n    'Data',\n    'TransactionInactive',\n    'ReadOnly',\n    'Version',\n    'NotFound',\n    'InvalidState',\n    'InvalidAccess',\n    'Abort',\n    'Timeout',\n    'QuotaExceeded',\n    'Syntax',\n    'DataClone'\n];\nvar errorList = dexieErrorNames.concat(idbDomErrorNames);\nvar defaultTexts = {\n    VersionChanged: \"Database version changed by other database connection\",\n    DatabaseClosed: \"Database has been closed\",\n    Abort: \"Transaction aborted\",\n    TransactionInactive: \"Transaction has already completed or failed\",\n    MissingAPI: \"IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb\"\n};\nfunction DexieError(name, msg) {\n    this._e = getErrorWithStack();\n    this.name = name;\n    this.message = msg;\n}\nderive(DexieError).from(Error).extend({\n    stack: {\n        get: function () {\n            return this._stack ||\n                (this._stack = this.name + \": \" + this.message + prettyStack(this._e, 2));\n        }\n    },\n    toString: function () { return this.name + \": \" + this.message; }\n});\nfunction getMultiErrorMessage(msg, failures) {\n    return msg + \". Errors: \" + Object.keys(failures)\n        .map(key => failures[key].toString())\n        .filter((v, i, s) => s.indexOf(v) === i)\n        .join('\\n');\n}\nfunction ModifyError(msg, failures, successCount, failedKeys) {\n    this._e = getErrorWithStack();\n    this.failures = failures;\n    this.failedKeys = failedKeys;\n    this.successCount = successCount;\n    this.message = getMultiErrorMessage(msg, failures);\n}\nderive(ModifyError).from(DexieError);\nfunction BulkError(msg, failures) {\n    this._e = getErrorWithStack();\n    this.name = \"BulkError\";\n    this.failures = Object.keys(failures).map(pos => failures[pos]);\n    this.failuresByPos = failures;\n    this.message = getMultiErrorMessage(msg, failures);\n}\nderive(BulkError).from(DexieError);\nvar errnames = errorList.reduce((obj, name) => (obj[name] = name + \"Error\", obj), {});\nconst BaseException = DexieError;\nvar exceptions = errorList.reduce((obj, name) => {\n    var fullName = name + \"Error\";\n    function DexieError(msgOrInner, inner) {\n        this._e = getErrorWithStack();\n        this.name = fullName;\n        if (!msgOrInner) {\n            this.message = defaultTexts[name] || fullName;\n            this.inner = null;\n        }\n        else if (typeof msgOrInner === 'string') {\n            this.message = `${msgOrInner}${!inner ? '' : '\\n ' + inner}`;\n            this.inner = inner || null;\n        }\n        else if (typeof msgOrInner === 'object') {\n            this.message = `${msgOrInner.name} ${msgOrInner.message}`;\n            this.inner = msgOrInner;\n        }\n    }\n    derive(DexieError).from(BaseException);\n    obj[name] = DexieError;\n    return obj;\n}, {});\nexceptions.Syntax = SyntaxError;\nexceptions.Type = TypeError;\nexceptions.Range = RangeError;\nvar exceptionMap = idbDomErrorNames.reduce((obj, name) => {\n    obj[name + \"Error\"] = exceptions[name];\n    return obj;\n}, {});\nfunction mapError(domError, message) {\n    if (!domError || domError instanceof DexieError || domError instanceof TypeError || domError instanceof SyntaxError || !domError.name || !exceptionMap[domError.name])\n        return domError;\n    var rv = new exceptionMap[domError.name](message || domError.message, domError);\n    if (\"stack\" in domError) {\n        setProp(rv, \"stack\", { get: function () {\n                return this.inner.stack;\n            } });\n    }\n    return rv;\n}\nvar fullNameExceptions = errorList.reduce((obj, name) => {\n    if ([\"Syntax\", \"Type\", \"Range\"].indexOf(name) === -1)\n        obj[name + \"Error\"] = exceptions[name];\n    return obj;\n}, {});\nfullNameExceptions.ModifyError = ModifyError;\nfullNameExceptions.DexieError = DexieError;\nfullNameExceptions.BulkError = BulkError;\n\nfunction nop() { }\nfunction mirror(val) { return val; }\nfunction pureFunctionChain(f1, f2) {\n    if (f1 == null || f1 === mirror)\n        return f2;\n    return function (val) {\n        return f2(f1(val));\n    };\n}\nfunction callBoth(on1, on2) {\n    return function () {\n        on1.apply(this, arguments);\n        on2.apply(this, arguments);\n    };\n}\nfunction hookCreatingChain(f1, f2) {\n    if (f1 === nop)\n        return f2;\n    return function () {\n        var res = f1.apply(this, arguments);\n        if (res !== undefined)\n            arguments[0] = res;\n        var onsuccess = this.onsuccess,\n        onerror = this.onerror;\n        this.onsuccess = null;\n        this.onerror = null;\n        var res2 = f2.apply(this, arguments);\n        if (onsuccess)\n            this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n        if (onerror)\n            this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n        return res2 !== undefined ? res2 : res;\n    };\n}\nfunction hookDeletingChain(f1, f2) {\n    if (f1 === nop)\n        return f2;\n    return function () {\n        f1.apply(this, arguments);\n        var onsuccess = this.onsuccess,\n        onerror = this.onerror;\n        this.onsuccess = this.onerror = null;\n        f2.apply(this, arguments);\n        if (onsuccess)\n            this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n        if (onerror)\n            this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n    };\n}\nfunction hookUpdatingChain(f1, f2) {\n    if (f1 === nop)\n        return f2;\n    return function (modifications) {\n        var res = f1.apply(this, arguments);\n        extend(modifications, res);\n        var onsuccess = this.onsuccess,\n        onerror = this.onerror;\n        this.onsuccess = null;\n        this.onerror = null;\n        var res2 = f2.apply(this, arguments);\n        if (onsuccess)\n            this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n        if (onerror)\n            this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n        return res === undefined ?\n            (res2 === undefined ? undefined : res2) :\n            (extend(res, res2));\n    };\n}\nfunction reverseStoppableEventChain(f1, f2) {\n    if (f1 === nop)\n        return f2;\n    return function () {\n        if (f2.apply(this, arguments) === false)\n            return false;\n        return f1.apply(this, arguments);\n    };\n}\nfunction promisableChain(f1, f2) {\n    if (f1 === nop)\n        return f2;\n    return function () {\n        var res = f1.apply(this, arguments);\n        if (res && typeof res.then === 'function') {\n            var thiz = this, i = arguments.length, args = new Array(i);\n            while (i--)\n                args[i] = arguments[i];\n            return res.then(function () {\n                return f2.apply(thiz, args);\n            });\n        }\n        return f2.apply(this, arguments);\n    };\n}\n\nvar INTERNAL = {};\nconst LONG_STACKS_CLIP_LIMIT = 100,\nMAX_LONG_STACKS = 20, ZONE_ECHO_LIMIT = 100, [resolvedNativePromise, nativePromiseProto, resolvedGlobalPromise] = typeof Promise === 'undefined' ?\n    [] :\n    (() => {\n        let globalP = Promise.resolve();\n        if (typeof crypto === 'undefined' || !crypto.subtle)\n            return [globalP, getProto(globalP), globalP];\n        const nativeP = crypto.subtle.digest(\"SHA-512\", new Uint8Array([0]));\n        return [\n            nativeP,\n            getProto(nativeP),\n            globalP\n        ];\n    })(), nativePromiseThen = nativePromiseProto && nativePromiseProto.then;\nconst NativePromise = resolvedNativePromise && resolvedNativePromise.constructor;\nconst patchGlobalPromise = !!resolvedGlobalPromise;\nvar stack_being_generated = false;\nvar schedulePhysicalTick = resolvedGlobalPromise ?\n    () => { resolvedGlobalPromise.then(physicalTick); }\n    :\n        _global.setImmediate ?\n            setImmediate.bind(null, physicalTick) :\n            _global.MutationObserver ?\n                () => {\n                    var hiddenDiv = document.createElement(\"div\");\n                    (new MutationObserver(() => {\n                        physicalTick();\n                        hiddenDiv = null;\n                    })).observe(hiddenDiv, { attributes: true });\n                    hiddenDiv.setAttribute('i', '1');\n                } :\n                () => { setTimeout(physicalTick, 0); };\nvar asap = function (callback, args) {\n    microtickQueue.push([callback, args]);\n    if (needsNewPhysicalTick) {\n        schedulePhysicalTick();\n        needsNewPhysicalTick = false;\n    }\n};\nvar isOutsideMicroTick = true,\nneedsNewPhysicalTick = true,\nunhandledErrors = [],\nrejectingErrors = [],\ncurrentFulfiller = null, rejectionMapper = mirror;\nvar globalPSD = {\n    id: 'global',\n    global: true,\n    ref: 0,\n    unhandleds: [],\n    onunhandled: globalError,\n    pgp: false,\n    env: {},\n    finalize: function () {\n        this.unhandleds.forEach(uh => {\n            try {\n                globalError(uh[0], uh[1]);\n            }\n            catch (e) { }\n        });\n    }\n};\nvar PSD = globalPSD;\nvar microtickQueue = [];\nvar numScheduledCalls = 0;\nvar tickFinalizers = [];\nfunction DexiePromise(fn) {\n    if (typeof this !== 'object')\n        throw new TypeError('Promises must be constructed via new');\n    this._listeners = [];\n    this.onuncatched = nop;\n    this._lib = false;\n    var psd = (this._PSD = PSD);\n    if (debug) {\n        this._stackHolder = getErrorWithStack();\n        this._prev = null;\n        this._numPrev = 0;\n    }\n    if (typeof fn !== 'function') {\n        if (fn !== INTERNAL)\n            throw new TypeError('Not a function');\n        this._state = arguments[1];\n        this._value = arguments[2];\n        if (this._state === false)\n            handleRejection(this, this._value);\n        return;\n    }\n    this._state = null;\n    this._value = null;\n    ++psd.ref;\n    executePromiseTask(this, fn);\n}\nconst thenProp = {\n    get: function () {\n        var psd = PSD, microTaskId = totalEchoes;\n        function then(onFulfilled, onRejected) {\n            var possibleAwait = !psd.global && (psd !== PSD || microTaskId !== totalEchoes);\n            const cleanup = possibleAwait && !decrementExpectedAwaits();\n            var rv = new DexiePromise((resolve, reject) => {\n                propagateToListener(this, new Listener(nativeAwaitCompatibleWrap(onFulfilled, psd, possibleAwait, cleanup), nativeAwaitCompatibleWrap(onRejected, psd, possibleAwait, cleanup), resolve, reject, psd));\n            });\n            debug && linkToPreviousPromise(rv, this);\n            return rv;\n        }\n        then.prototype = INTERNAL;\n        return then;\n    },\n    set: function (value) {\n        setProp(this, 'then', value && value.prototype === INTERNAL ?\n            thenProp :\n            {\n                get: function () {\n                    return value;\n                },\n                set: thenProp.set\n            });\n    }\n};\nprops(DexiePromise.prototype, {\n    then: thenProp,\n    _then: function (onFulfilled, onRejected) {\n        propagateToListener(this, new Listener(null, null, onFulfilled, onRejected, PSD));\n    },\n    catch: function (onRejected) {\n        if (arguments.length === 1)\n            return this.then(null, onRejected);\n        var type = arguments[0], handler = arguments[1];\n        return typeof type === 'function' ? this.then(null, err =>\n        err instanceof type ? handler(err) : PromiseReject(err))\n            : this.then(null, err =>\n            err && err.name === type ? handler(err) : PromiseReject(err));\n    },\n    finally: function (onFinally) {\n        return this.then(value => {\n            onFinally();\n            return value;\n        }, err => {\n            onFinally();\n            return PromiseReject(err);\n        });\n    },\n    stack: {\n        get: function () {\n            if (this._stack)\n                return this._stack;\n            try {\n                stack_being_generated = true;\n                var stacks = getStack(this, [], MAX_LONG_STACKS);\n                var stack = stacks.join(\"\\nFrom previous: \");\n                if (this._state !== null)\n                    this._stack = stack;\n                return stack;\n            }\n            finally {\n                stack_being_generated = false;\n            }\n        }\n    },\n    timeout: function (ms, msg) {\n        return ms < Infinity ?\n            new DexiePromise((resolve, reject) => {\n                var handle = setTimeout(() => reject(new exceptions.Timeout(msg)), ms);\n                this.then(resolve, reject).finally(clearTimeout.bind(null, handle));\n            }) : this;\n    }\n});\nif (typeof Symbol !== 'undefined' && Symbol.toStringTag)\n    setProp(DexiePromise.prototype, Symbol.toStringTag, 'Dexie.Promise');\nglobalPSD.env = snapShot();\nfunction Listener(onFulfilled, onRejected, resolve, reject, zone) {\n    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n    this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n    this.resolve = resolve;\n    this.reject = reject;\n    this.psd = zone;\n}\nprops(DexiePromise, {\n    all: function () {\n        var values = getArrayOf.apply(null, arguments)\n            .map(onPossibleParallellAsync);\n        return new DexiePromise(function (resolve, reject) {\n            if (values.length === 0)\n                resolve([]);\n            var remaining = values.length;\n            values.forEach((a, i) => DexiePromise.resolve(a).then(x => {\n                values[i] = x;\n                if (!--remaining)\n                    resolve(values);\n            }, reject));\n        });\n    },\n    resolve: value => {\n        if (value instanceof DexiePromise)\n            return value;\n        if (value && typeof value.then === 'function')\n            return new DexiePromise((resolve, reject) => {\n                value.then(resolve, reject);\n            });\n        var rv = new DexiePromise(INTERNAL, true, value);\n        linkToPreviousPromise(rv, currentFulfiller);\n        return rv;\n    },\n    reject: PromiseReject,\n    race: function () {\n        var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n        return new DexiePromise((resolve, reject) => {\n            values.map(value => DexiePromise.resolve(value).then(resolve, reject));\n        });\n    },\n    PSD: {\n        get: () => PSD,\n        set: value => PSD = value\n    },\n    totalEchoes: { get: () => totalEchoes },\n    newPSD: newScope,\n    usePSD: usePSD,\n    scheduler: {\n        get: () => asap,\n        set: value => { asap = value; }\n    },\n    rejectionMapper: {\n        get: () => rejectionMapper,\n        set: value => { rejectionMapper = value; }\n    },\n    follow: (fn, zoneProps) => {\n        return new DexiePromise((resolve, reject) => {\n            return newScope((resolve, reject) => {\n                var psd = PSD;\n                psd.unhandleds = [];\n                psd.onunhandled = reject;\n                psd.finalize = callBoth(function () {\n                    run_at_end_of_this_or_next_physical_tick(() => {\n                        this.unhandleds.length === 0 ? resolve() : reject(this.unhandleds[0]);\n                    });\n                }, psd.finalize);\n                fn();\n            }, zoneProps, resolve, reject);\n        });\n    }\n});\nif (NativePromise) {\n    if (NativePromise.allSettled)\n        setProp(DexiePromise, \"allSettled\", function () {\n            const possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n            return new DexiePromise(resolve => {\n                if (possiblePromises.length === 0)\n                    resolve([]);\n                let remaining = possiblePromises.length;\n                const results = new Array(remaining);\n                possiblePromises.forEach((p, i) => DexiePromise.resolve(p).then(value => results[i] = { status: \"fulfilled\", value }, reason => results[i] = { status: \"rejected\", reason })\n                    .then(() => --remaining || resolve(results)));\n            });\n        });\n    if (NativePromise.any && typeof AggregateError !== 'undefined')\n        setProp(DexiePromise, \"any\", function () {\n            const possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n            return new DexiePromise((resolve, reject) => {\n                if (possiblePromises.length === 0)\n                    reject(new AggregateError([]));\n                let remaining = possiblePromises.length;\n                const failures = new Array(remaining);\n                possiblePromises.forEach((p, i) => DexiePromise.resolve(p).then(value => resolve(value), failure => {\n                    failures[i] = failure;\n                    if (!--remaining)\n                        reject(new AggregateError(failures));\n                }));\n            });\n        });\n}\nfunction executePromiseTask(promise, fn) {\n    try {\n        fn(value => {\n            if (promise._state !== null)\n                return;\n            if (value === promise)\n                throw new TypeError('A promise cannot be resolved with itself.');\n            var shouldExecuteTick = promise._lib && beginMicroTickScope();\n            if (value && typeof value.then === 'function') {\n                executePromiseTask(promise, (resolve, reject) => {\n                    value instanceof DexiePromise ?\n                        value._then(resolve, reject) :\n                        value.then(resolve, reject);\n                });\n            }\n            else {\n                promise._state = true;\n                promise._value = value;\n                propagateAllListeners(promise);\n            }\n            if (shouldExecuteTick)\n                endMicroTickScope();\n        }, handleRejection.bind(null, promise));\n    }\n    catch (ex) {\n        handleRejection(promise, ex);\n    }\n}\nfunction handleRejection(promise, reason) {\n    rejectingErrors.push(reason);\n    if (promise._state !== null)\n        return;\n    var shouldExecuteTick = promise._lib && beginMicroTickScope();\n    reason = rejectionMapper(reason);\n    promise._state = false;\n    promise._value = reason;\n    debug && reason !== null && typeof reason === 'object' && !reason._promise && tryCatch(() => {\n        var origProp = getPropertyDescriptor(reason, \"stack\");\n        reason._promise = promise;\n        setProp(reason, \"stack\", {\n            get: () => stack_being_generated ?\n                origProp && (origProp.get ?\n                    origProp.get.apply(reason) :\n                    origProp.value) :\n                promise.stack\n        });\n    });\n    addPossiblyUnhandledError(promise);\n    propagateAllListeners(promise);\n    if (shouldExecuteTick)\n        endMicroTickScope();\n}\nfunction propagateAllListeners(promise) {\n    var listeners = promise._listeners;\n    promise._listeners = [];\n    for (var i = 0, len = listeners.length; i < len; ++i) {\n        propagateToListener(promise, listeners[i]);\n    }\n    var psd = promise._PSD;\n    --psd.ref || psd.finalize();\n    if (numScheduledCalls === 0) {\n        ++numScheduledCalls;\n        asap(() => {\n            if (--numScheduledCalls === 0)\n                finalizePhysicalTick();\n        }, []);\n    }\n}\nfunction propagateToListener(promise, listener) {\n    if (promise._state === null) {\n        promise._listeners.push(listener);\n        return;\n    }\n    var cb = promise._state ? listener.onFulfilled : listener.onRejected;\n    if (cb === null) {\n        return (promise._state ? listener.resolve : listener.reject)(promise._value);\n    }\n    ++listener.psd.ref;\n    ++numScheduledCalls;\n    asap(callListener, [cb, promise, listener]);\n}\nfunction callListener(cb, promise, listener) {\n    try {\n        currentFulfiller = promise;\n        var ret, value = promise._value;\n        if (promise._state) {\n            ret = cb(value);\n        }\n        else {\n            if (rejectingErrors.length)\n                rejectingErrors = [];\n            ret = cb(value);\n            if (rejectingErrors.indexOf(value) === -1)\n                markErrorAsHandled(promise);\n        }\n        listener.resolve(ret);\n    }\n    catch (e) {\n        listener.reject(e);\n    }\n    finally {\n        currentFulfiller = null;\n        if (--numScheduledCalls === 0)\n            finalizePhysicalTick();\n        --listener.psd.ref || listener.psd.finalize();\n    }\n}\nfunction getStack(promise, stacks, limit) {\n    if (stacks.length === limit)\n        return stacks;\n    var stack = \"\";\n    if (promise._state === false) {\n        var failure = promise._value, errorName, message;\n        if (failure != null) {\n            errorName = failure.name || \"Error\";\n            message = failure.message || failure;\n            stack = prettyStack(failure, 0);\n        }\n        else {\n            errorName = failure;\n            message = \"\";\n        }\n        stacks.push(errorName + (message ? \": \" + message : \"\") + stack);\n    }\n    if (debug) {\n        stack = prettyStack(promise._stackHolder, 2);\n        if (stack && stacks.indexOf(stack) === -1)\n            stacks.push(stack);\n        if (promise._prev)\n            getStack(promise._prev, stacks, limit);\n    }\n    return stacks;\n}\nfunction linkToPreviousPromise(promise, prev) {\n    var numPrev = prev ? prev._numPrev + 1 : 0;\n    if (numPrev < LONG_STACKS_CLIP_LIMIT) {\n        promise._prev = prev;\n        promise._numPrev = numPrev;\n    }\n}\nfunction physicalTick() {\n    beginMicroTickScope() && endMicroTickScope();\n}\nfunction beginMicroTickScope() {\n    var wasRootExec = isOutsideMicroTick;\n    isOutsideMicroTick = false;\n    needsNewPhysicalTick = false;\n    return wasRootExec;\n}\nfunction endMicroTickScope() {\n    var callbacks, i, l;\n    do {\n        while (microtickQueue.length > 0) {\n            callbacks = microtickQueue;\n            microtickQueue = [];\n            l = callbacks.length;\n            for (i = 0; i < l; ++i) {\n                var item = callbacks[i];\n                item[0].apply(null, item[1]);\n            }\n        }\n    } while (microtickQueue.length > 0);\n    isOutsideMicroTick = true;\n    needsNewPhysicalTick = true;\n}\nfunction finalizePhysicalTick() {\n    var unhandledErrs = unhandledErrors;\n    unhandledErrors = [];\n    unhandledErrs.forEach(p => {\n        p._PSD.onunhandled.call(null, p._value, p);\n    });\n    var finalizers = tickFinalizers.slice(0);\n    var i = finalizers.length;\n    while (i)\n        finalizers[--i]();\n}\nfunction run_at_end_of_this_or_next_physical_tick(fn) {\n    function finalizer() {\n        fn();\n        tickFinalizers.splice(tickFinalizers.indexOf(finalizer), 1);\n    }\n    tickFinalizers.push(finalizer);\n    ++numScheduledCalls;\n    asap(() => {\n        if (--numScheduledCalls === 0)\n            finalizePhysicalTick();\n    }, []);\n}\nfunction addPossiblyUnhandledError(promise) {\n    if (!unhandledErrors.some(p => p._value === promise._value))\n        unhandledErrors.push(promise);\n}\nfunction markErrorAsHandled(promise) {\n    var i = unhandledErrors.length;\n    while (i)\n        if (unhandledErrors[--i]._value === promise._value) {\n            unhandledErrors.splice(i, 1);\n            return;\n        }\n}\nfunction PromiseReject(reason) {\n    return new DexiePromise(INTERNAL, false, reason);\n}\nfunction wrap(fn, errorCatcher) {\n    var psd = PSD;\n    return function () {\n        var wasRootExec = beginMicroTickScope(), outerScope = PSD;\n        try {\n            switchToZone(psd, true);\n            return fn.apply(this, arguments);\n        }\n        catch (e) {\n            errorCatcher && errorCatcher(e);\n        }\n        finally {\n            switchToZone(outerScope, false);\n            if (wasRootExec)\n                endMicroTickScope();\n        }\n    };\n}\nconst task = { awaits: 0, echoes: 0, id: 0 };\nvar taskCounter = 0;\nvar zoneStack = [];\nvar zoneEchoes = 0;\nvar totalEchoes = 0;\nvar zone_id_counter = 0;\nfunction newScope(fn, props, a1, a2) {\n    var parent = PSD, psd = Object.create(parent);\n    psd.parent = parent;\n    psd.ref = 0;\n    psd.global = false;\n    psd.id = ++zone_id_counter;\n    var globalEnv = globalPSD.env;\n    psd.env = patchGlobalPromise ? {\n        Promise: DexiePromise,\n        PromiseProp: { value: DexiePromise, configurable: true, writable: true },\n        all: DexiePromise.all,\n        race: DexiePromise.race,\n        allSettled: DexiePromise.allSettled,\n        any: DexiePromise.any,\n        resolve: DexiePromise.resolve,\n        reject: DexiePromise.reject,\n        nthen: getPatchedPromiseThen(globalEnv.nthen, psd),\n        gthen: getPatchedPromiseThen(globalEnv.gthen, psd)\n    } : {};\n    if (props)\n        extend(psd, props);\n    ++parent.ref;\n    psd.finalize = function () {\n        --this.parent.ref || this.parent.finalize();\n    };\n    var rv = usePSD(psd, fn, a1, a2);\n    if (psd.ref === 0)\n        psd.finalize();\n    return rv;\n}\nfunction incrementExpectedAwaits() {\n    if (!task.id)\n        task.id = ++taskCounter;\n    ++task.awaits;\n    task.echoes += ZONE_ECHO_LIMIT;\n    return task.id;\n}\nfunction decrementExpectedAwaits() {\n    if (!task.awaits)\n        return false;\n    if (--task.awaits === 0)\n        task.id = 0;\n    task.echoes = task.awaits * ZONE_ECHO_LIMIT;\n    return true;\n}\nif (('' + nativePromiseThen).indexOf('[native code]') === -1) {\n    incrementExpectedAwaits = decrementExpectedAwaits = nop;\n}\nfunction onPossibleParallellAsync(possiblePromise) {\n    if (task.echoes && possiblePromise && possiblePromise.constructor === NativePromise) {\n        incrementExpectedAwaits();\n        return possiblePromise.then(x => {\n            decrementExpectedAwaits();\n            return x;\n        }, e => {\n            decrementExpectedAwaits();\n            return rejection(e);\n        });\n    }\n    return possiblePromise;\n}\nfunction zoneEnterEcho(targetZone) {\n    ++totalEchoes;\n    if (!task.echoes || --task.echoes === 0) {\n        task.echoes = task.id = 0;\n    }\n    zoneStack.push(PSD);\n    switchToZone(targetZone, true);\n}\nfunction zoneLeaveEcho() {\n    var zone = zoneStack[zoneStack.length - 1];\n    zoneStack.pop();\n    switchToZone(zone, false);\n}\nfunction switchToZone(targetZone, bEnteringZone) {\n    var currentZone = PSD;\n    if (bEnteringZone ? task.echoes && (!zoneEchoes++ || targetZone !== PSD) : zoneEchoes && (!--zoneEchoes || targetZone !== PSD)) {\n        enqueueNativeMicroTask(bEnteringZone ? zoneEnterEcho.bind(null, targetZone) : zoneLeaveEcho);\n    }\n    if (targetZone === PSD)\n        return;\n    PSD = targetZone;\n    if (currentZone === globalPSD)\n        globalPSD.env = snapShot();\n    if (patchGlobalPromise) {\n        var GlobalPromise = globalPSD.env.Promise;\n        var targetEnv = targetZone.env;\n        nativePromiseProto.then = targetEnv.nthen;\n        GlobalPromise.prototype.then = targetEnv.gthen;\n        if (currentZone.global || targetZone.global) {\n            Object.defineProperty(_global, 'Promise', targetEnv.PromiseProp);\n            GlobalPromise.all = targetEnv.all;\n            GlobalPromise.race = targetEnv.race;\n            GlobalPromise.resolve = targetEnv.resolve;\n            GlobalPromise.reject = targetEnv.reject;\n            if (targetEnv.allSettled)\n                GlobalPromise.allSettled = targetEnv.allSettled;\n            if (targetEnv.any)\n                GlobalPromise.any = targetEnv.any;\n        }\n    }\n}\nfunction snapShot() {\n    var GlobalPromise = _global.Promise;\n    return patchGlobalPromise ? {\n        Promise: GlobalPromise,\n        PromiseProp: Object.getOwnPropertyDescriptor(_global, \"Promise\"),\n        all: GlobalPromise.all,\n        race: GlobalPromise.race,\n        allSettled: GlobalPromise.allSettled,\n        any: GlobalPromise.any,\n        resolve: GlobalPromise.resolve,\n        reject: GlobalPromise.reject,\n        nthen: nativePromiseProto.then,\n        gthen: GlobalPromise.prototype.then\n    } : {};\n}\nfunction usePSD(psd, fn, a1, a2, a3) {\n    var outerScope = PSD;\n    try {\n        switchToZone(psd, true);\n        return fn(a1, a2, a3);\n    }\n    finally {\n        switchToZone(outerScope, false);\n    }\n}\nfunction enqueueNativeMicroTask(job) {\n    nativePromiseThen.call(resolvedNativePromise, job);\n}\nfunction nativeAwaitCompatibleWrap(fn, zone, possibleAwait, cleanup) {\n    return typeof fn !== 'function' ? fn : function () {\n        var outerZone = PSD;\n        if (possibleAwait)\n            incrementExpectedAwaits();\n        switchToZone(zone, true);\n        try {\n            return fn.apply(this, arguments);\n        }\n        finally {\n            switchToZone(outerZone, false);\n            if (cleanup)\n                enqueueNativeMicroTask(decrementExpectedAwaits);\n        }\n    };\n}\nfunction getPatchedPromiseThen(origThen, zone) {\n    return function (onResolved, onRejected) {\n        return origThen.call(this, nativeAwaitCompatibleWrap(onResolved, zone), nativeAwaitCompatibleWrap(onRejected, zone));\n    };\n}\nconst UNHANDLEDREJECTION = \"unhandledrejection\";\nfunction globalError(err, promise) {\n    var rv;\n    try {\n        rv = promise.onuncatched(err);\n    }\n    catch (e) { }\n    if (rv !== false)\n        try {\n            var event, eventData = { promise: promise, reason: err };\n            if (_global.document && document.createEvent) {\n                event = document.createEvent('Event');\n                event.initEvent(UNHANDLEDREJECTION, true, true);\n                extend(event, eventData);\n            }\n            else if (_global.CustomEvent) {\n                event = new CustomEvent(UNHANDLEDREJECTION, { detail: eventData });\n                extend(event, eventData);\n            }\n            if (event && _global.dispatchEvent) {\n                dispatchEvent(event);\n                if (!_global.PromiseRejectionEvent && _global.onunhandledrejection)\n                    try {\n                        _global.onunhandledrejection(event);\n                    }\n                    catch (_) { }\n            }\n            if (debug && event && !event.defaultPrevented) {\n                console.warn(`Unhandled rejection: ${err.stack || err}`);\n            }\n        }\n        catch (e) { }\n}\nvar rejection = DexiePromise.reject;\n\nfunction tempTransaction(db, mode, storeNames, fn) {\n    if (!db.idbdb || (!db._state.openComplete && (!PSD.letThrough && !db._vip))) {\n        if (db._state.openComplete) {\n            return rejection(new exceptions.DatabaseClosed(db._state.dbOpenError));\n        }\n        if (!db._state.isBeingOpened) {\n            if (!db._options.autoOpen)\n                return rejection(new exceptions.DatabaseClosed());\n            db.open().catch(nop);\n        }\n        return db._state.dbReadyPromise.then(() => tempTransaction(db, mode, storeNames, fn));\n    }\n    else {\n        var trans = db._createTransaction(mode, storeNames, db._dbSchema);\n        try {\n            trans.create();\n            db._state.PR1398_maxLoop = 3;\n        }\n        catch (ex) {\n            if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {\n                console.warn('Dexie: Need to reopen db');\n                db._close();\n                return db.open().then(() => tempTransaction(db, mode, storeNames, fn));\n            }\n            return rejection(ex);\n        }\n        return trans._promise(mode, (resolve, reject) => {\n            return newScope(() => {\n                PSD.trans = trans;\n                return fn(resolve, reject, trans);\n            });\n        }).then(result => {\n            return trans._completion.then(() => result);\n        });\n    }\n}\n\nconst DEXIE_VERSION = '3.2.4';\nconst maxString = String.fromCharCode(65535);\nconst minKey = -Infinity;\nconst INVALID_KEY_ARGUMENT = \"Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.\";\nconst STRING_EXPECTED = \"String expected.\";\nconst connections = [];\nconst isIEOrEdge = typeof navigator !== 'undefined' && /(MSIE|Trident|Edge)/.test(navigator.userAgent);\nconst hasIEDeleteObjectStoreBug = isIEOrEdge;\nconst hangsOnDeleteLargeKeyRange = isIEOrEdge;\nconst dexieStackFrameFilter = frame => !/(dexie\\.js|dexie\\.min\\.js)/.test(frame);\nconst DBNAMES_DB = '__dbnames';\nconst READONLY = 'readonly';\nconst READWRITE = 'readwrite';\n\nfunction combine(filter1, filter2) {\n    return filter1 ?\n        filter2 ?\n            function () { return filter1.apply(this, arguments) && filter2.apply(this, arguments); } :\n            filter1 :\n        filter2;\n}\n\nconst AnyRange = {\n    type: 3 ,\n    lower: -Infinity,\n    lowerOpen: false,\n    upper: [[]],\n    upperOpen: false\n};\n\nfunction workaroundForUndefinedPrimKey(keyPath) {\n    return typeof keyPath === \"string\" && !/\\./.test(keyPath)\n        ? (obj) => {\n            if (obj[keyPath] === undefined && (keyPath in obj)) {\n                obj = deepClone(obj);\n                delete obj[keyPath];\n            }\n            return obj;\n        }\n        : (obj) => obj;\n}\n\nclass Table {\n    _trans(mode, fn, writeLocked) {\n        const trans = this._tx || PSD.trans;\n        const tableName = this.name;\n        function checkTableInTransaction(resolve, reject, trans) {\n            if (!trans.schema[tableName])\n                throw new exceptions.NotFound(\"Table \" + tableName + \" not part of transaction\");\n            return fn(trans.idbtrans, trans);\n        }\n        const wasRootExec = beginMicroTickScope();\n        try {\n            return trans && trans.db === this.db ?\n                trans === PSD.trans ?\n                    trans._promise(mode, checkTableInTransaction, writeLocked) :\n                    newScope(() => trans._promise(mode, checkTableInTransaction, writeLocked), { trans: trans, transless: PSD.transless || PSD }) :\n                tempTransaction(this.db, mode, [this.name], checkTableInTransaction);\n        }\n        finally {\n            if (wasRootExec)\n                endMicroTickScope();\n        }\n    }\n    get(keyOrCrit, cb) {\n        if (keyOrCrit && keyOrCrit.constructor === Object)\n            return this.where(keyOrCrit).first(cb);\n        return this._trans('readonly', (trans) => {\n            return this.core.get({ trans, key: keyOrCrit })\n                .then(res => this.hook.reading.fire(res));\n        }).then(cb);\n    }\n    where(indexOrCrit) {\n        if (typeof indexOrCrit === 'string')\n            return new this.db.WhereClause(this, indexOrCrit);\n        if (isArray(indexOrCrit))\n            return new this.db.WhereClause(this, `[${indexOrCrit.join('+')}]`);\n        const keyPaths = keys(indexOrCrit);\n        if (keyPaths.length === 1)\n            return this\n                .where(keyPaths[0])\n                .equals(indexOrCrit[keyPaths[0]]);\n        const compoundIndex = this.schema.indexes.concat(this.schema.primKey).filter(ix => ix.compound &&\n            keyPaths.every(keyPath => ix.keyPath.indexOf(keyPath) >= 0) &&\n            ix.keyPath.every(keyPath => keyPaths.indexOf(keyPath) >= 0))[0];\n        if (compoundIndex && this.db._maxKey !== maxString)\n            return this\n                .where(compoundIndex.name)\n                .equals(compoundIndex.keyPath.map(kp => indexOrCrit[kp]));\n        if (!compoundIndex && debug)\n            console.warn(`The query ${JSON.stringify(indexOrCrit)} on ${this.name} would benefit of a ` +\n                `compound index [${keyPaths.join('+')}]`);\n        const { idxByName } = this.schema;\n        const idb = this.db._deps.indexedDB;\n        function equals(a, b) {\n            try {\n                return idb.cmp(a, b) === 0;\n            }\n            catch (e) {\n                return false;\n            }\n        }\n        const [idx, filterFunction] = keyPaths.reduce(([prevIndex, prevFilterFn], keyPath) => {\n            const index = idxByName[keyPath];\n            const value = indexOrCrit[keyPath];\n            return [\n                prevIndex || index,\n                prevIndex || !index ?\n                    combine(prevFilterFn, index && index.multi ?\n                        x => {\n                            const prop = getByKeyPath(x, keyPath);\n                            return isArray(prop) && prop.some(item => equals(value, item));\n                        } : x => equals(value, getByKeyPath(x, keyPath)))\n                    : prevFilterFn\n            ];\n        }, [null, null]);\n        return idx ?\n            this.where(idx.name).equals(indexOrCrit[idx.keyPath])\n                .filter(filterFunction) :\n            compoundIndex ?\n                this.filter(filterFunction) :\n                this.where(keyPaths).equals('');\n    }\n    filter(filterFunction) {\n        return this.toCollection().and(filterFunction);\n    }\n    count(thenShortcut) {\n        return this.toCollection().count(thenShortcut);\n    }\n    offset(offset) {\n        return this.toCollection().offset(offset);\n    }\n    limit(numRows) {\n        return this.toCollection().limit(numRows);\n    }\n    each(callback) {\n        return this.toCollection().each(callback);\n    }\n    toArray(thenShortcut) {\n        return this.toCollection().toArray(thenShortcut);\n    }\n    toCollection() {\n        return new this.db.Collection(new this.db.WhereClause(this));\n    }\n    orderBy(index) {\n        return new this.db.Collection(new this.db.WhereClause(this, isArray(index) ?\n            `[${index.join('+')}]` :\n            index));\n    }\n    reverse() {\n        return this.toCollection().reverse();\n    }\n    mapToClass(constructor) {\n        this.schema.mappedClass = constructor;\n        const readHook = obj => {\n            if (!obj)\n                return obj;\n            const res = Object.create(constructor.prototype);\n            for (var m in obj)\n                if (hasOwn(obj, m))\n                    try {\n                        res[m] = obj[m];\n                    }\n                    catch (_) { }\n            return res;\n        };\n        if (this.schema.readHook) {\n            this.hook.reading.unsubscribe(this.schema.readHook);\n        }\n        this.schema.readHook = readHook;\n        this.hook(\"reading\", readHook);\n        return constructor;\n    }\n    defineClass() {\n        function Class(content) {\n            extend(this, content);\n        }\n        return this.mapToClass(Class);\n    }\n    add(obj, key) {\n        const { auto, keyPath } = this.schema.primKey;\n        let objToAdd = obj;\n        if (keyPath && auto) {\n            objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);\n        }\n        return this._trans('readwrite', trans => {\n            return this.core.mutate({ trans, type: 'add', keys: key != null ? [key] : null, values: [objToAdd] });\n        }).then(res => res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult)\n            .then(lastResult => {\n            if (keyPath) {\n                try {\n                    setByKeyPath(obj, keyPath, lastResult);\n                }\n                catch (_) { }\n            }\n            return lastResult;\n        });\n    }\n    update(keyOrObject, modifications) {\n        if (typeof keyOrObject === 'object' && !isArray(keyOrObject)) {\n            const key = getByKeyPath(keyOrObject, this.schema.primKey.keyPath);\n            if (key === undefined)\n                return rejection(new exceptions.InvalidArgument(\"Given object does not contain its primary key\"));\n            try {\n                if (typeof modifications !== \"function\") {\n                    keys(modifications).forEach(keyPath => {\n                        setByKeyPath(keyOrObject, keyPath, modifications[keyPath]);\n                    });\n                }\n                else {\n                    modifications(keyOrObject, { value: keyOrObject, primKey: key });\n                }\n            }\n            catch (_a) {\n            }\n            return this.where(\":id\").equals(key).modify(modifications);\n        }\n        else {\n            return this.where(\":id\").equals(keyOrObject).modify(modifications);\n        }\n    }\n    put(obj, key) {\n        const { auto, keyPath } = this.schema.primKey;\n        let objToAdd = obj;\n        if (keyPath && auto) {\n            objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);\n        }\n        return this._trans('readwrite', trans => this.core.mutate({ trans, type: 'put', values: [objToAdd], keys: key != null ? [key] : null }))\n            .then(res => res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult)\n            .then(lastResult => {\n            if (keyPath) {\n                try {\n                    setByKeyPath(obj, keyPath, lastResult);\n                }\n                catch (_) { }\n            }\n            return lastResult;\n        });\n    }\n    delete(key) {\n        return this._trans('readwrite', trans => this.core.mutate({ trans, type: 'delete', keys: [key] }))\n            .then(res => res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined);\n    }\n    clear() {\n        return this._trans('readwrite', trans => this.core.mutate({ trans, type: 'deleteRange', range: AnyRange }))\n            .then(res => res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined);\n    }\n    bulkGet(keys) {\n        return this._trans('readonly', trans => {\n            return this.core.getMany({\n                keys,\n                trans\n            }).then(result => result.map(res => this.hook.reading.fire(res)));\n        });\n    }\n    bulkAdd(objects, keysOrOptions, options) {\n        const keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;\n        options = options || (keys ? undefined : keysOrOptions);\n        const wantResults = options ? options.allKeys : undefined;\n        return this._trans('readwrite', trans => {\n            const { auto, keyPath } = this.schema.primKey;\n            if (keyPath && keys)\n                throw new exceptions.InvalidArgument(\"bulkAdd(): keys argument invalid on tables with inbound keys\");\n            if (keys && keys.length !== objects.length)\n                throw new exceptions.InvalidArgument(\"Arguments objects and keys must have the same length\");\n            const numObjects = objects.length;\n            let objectsToAdd = keyPath && auto ?\n                objects.map(workaroundForUndefinedPrimKey(keyPath)) :\n                objects;\n            return this.core.mutate({ trans, type: 'add', keys: keys, values: objectsToAdd, wantResults })\n                .then(({ numFailures, results, lastResult, failures }) => {\n                const result = wantResults ? results : lastResult;\n                if (numFailures === 0)\n                    return result;\n                throw new BulkError(`${this.name}.bulkAdd(): ${numFailures} of ${numObjects} operations failed`, failures);\n            });\n        });\n    }\n    bulkPut(objects, keysOrOptions, options) {\n        const keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;\n        options = options || (keys ? undefined : keysOrOptions);\n        const wantResults = options ? options.allKeys : undefined;\n        return this._trans('readwrite', trans => {\n            const { auto, keyPath } = this.schema.primKey;\n            if (keyPath && keys)\n                throw new exceptions.InvalidArgument(\"bulkPut(): keys argument invalid on tables with inbound keys\");\n            if (keys && keys.length !== objects.length)\n                throw new exceptions.InvalidArgument(\"Arguments objects and keys must have the same length\");\n            const numObjects = objects.length;\n            let objectsToPut = keyPath && auto ?\n                objects.map(workaroundForUndefinedPrimKey(keyPath)) :\n                objects;\n            return this.core.mutate({ trans, type: 'put', keys: keys, values: objectsToPut, wantResults })\n                .then(({ numFailures, results, lastResult, failures }) => {\n                const result = wantResults ? results : lastResult;\n                if (numFailures === 0)\n                    return result;\n                throw new BulkError(`${this.name}.bulkPut(): ${numFailures} of ${numObjects} operations failed`, failures);\n            });\n        });\n    }\n    bulkDelete(keys) {\n        const numKeys = keys.length;\n        return this._trans('readwrite', trans => {\n            return this.core.mutate({ trans, type: 'delete', keys: keys });\n        }).then(({ numFailures, lastResult, failures }) => {\n            if (numFailures === 0)\n                return lastResult;\n            throw new BulkError(`${this.name}.bulkDelete(): ${numFailures} of ${numKeys} operations failed`, failures);\n        });\n    }\n}\n\nfunction Events(ctx) {\n    var evs = {};\n    var rv = function (eventName, subscriber) {\n        if (subscriber) {\n            var i = arguments.length, args = new Array(i - 1);\n            while (--i)\n                args[i - 1] = arguments[i];\n            evs[eventName].subscribe.apply(null, args);\n            return ctx;\n        }\n        else if (typeof (eventName) === 'string') {\n            return evs[eventName];\n        }\n    };\n    rv.addEventType = add;\n    for (var i = 1, l = arguments.length; i < l; ++i) {\n        add(arguments[i]);\n    }\n    return rv;\n    function add(eventName, chainFunction, defaultFunction) {\n        if (typeof eventName === 'object')\n            return addConfiguredEvents(eventName);\n        if (!chainFunction)\n            chainFunction = reverseStoppableEventChain;\n        if (!defaultFunction)\n            defaultFunction = nop;\n        var context = {\n            subscribers: [],\n            fire: defaultFunction,\n            subscribe: function (cb) {\n                if (context.subscribers.indexOf(cb) === -1) {\n                    context.subscribers.push(cb);\n                    context.fire = chainFunction(context.fire, cb);\n                }\n            },\n            unsubscribe: function (cb) {\n                context.subscribers = context.subscribers.filter(function (fn) { return fn !== cb; });\n                context.fire = context.subscribers.reduce(chainFunction, defaultFunction);\n            }\n        };\n        evs[eventName] = rv[eventName] = context;\n        return context;\n    }\n    function addConfiguredEvents(cfg) {\n        keys(cfg).forEach(function (eventName) {\n            var args = cfg[eventName];\n            if (isArray(args)) {\n                add(eventName, cfg[eventName][0], cfg[eventName][1]);\n            }\n            else if (args === 'asap') {\n                var context = add(eventName, mirror, function fire() {\n                    var i = arguments.length, args = new Array(i);\n                    while (i--)\n                        args[i] = arguments[i];\n                    context.subscribers.forEach(function (fn) {\n                        asap$1(function fireEvent() {\n                            fn.apply(null, args);\n                        });\n                    });\n                });\n            }\n            else\n                throw new exceptions.InvalidArgument(\"Invalid event config\");\n        });\n    }\n}\n\nfunction makeClassConstructor(prototype, constructor) {\n    derive(constructor).from({ prototype });\n    return constructor;\n}\n\nfunction createTableConstructor(db) {\n    return makeClassConstructor(Table.prototype, function Table(name, tableSchema, trans) {\n        this.db = db;\n        this._tx = trans;\n        this.name = name;\n        this.schema = tableSchema;\n        this.hook = db._allTables[name] ? db._allTables[name].hook : Events(null, {\n            \"creating\": [hookCreatingChain, nop],\n            \"reading\": [pureFunctionChain, mirror],\n            \"updating\": [hookUpdatingChain, nop],\n            \"deleting\": [hookDeletingChain, nop]\n        });\n    });\n}\n\nfunction isPlainKeyRange(ctx, ignoreLimitFilter) {\n    return !(ctx.filter || ctx.algorithm || ctx.or) &&\n        (ignoreLimitFilter ? ctx.justLimit : !ctx.replayFilter);\n}\nfunction addFilter(ctx, fn) {\n    ctx.filter = combine(ctx.filter, fn);\n}\nfunction addReplayFilter(ctx, factory, isLimitFilter) {\n    var curr = ctx.replayFilter;\n    ctx.replayFilter = curr ? () => combine(curr(), factory()) : factory;\n    ctx.justLimit = isLimitFilter && !curr;\n}\nfunction addMatchFilter(ctx, fn) {\n    ctx.isMatch = combine(ctx.isMatch, fn);\n}\nfunction getIndexOrStore(ctx, coreSchema) {\n    if (ctx.isPrimKey)\n        return coreSchema.primaryKey;\n    const index = coreSchema.getIndexByKeyPath(ctx.index);\n    if (!index)\n        throw new exceptions.Schema(\"KeyPath \" + ctx.index + \" on object store \" + coreSchema.name + \" is not indexed\");\n    return index;\n}\nfunction openCursor(ctx, coreTable, trans) {\n    const index = getIndexOrStore(ctx, coreTable.schema);\n    return coreTable.openCursor({\n        trans,\n        values: !ctx.keysOnly,\n        reverse: ctx.dir === 'prev',\n        unique: !!ctx.unique,\n        query: {\n            index,\n            range: ctx.range\n        }\n    });\n}\nfunction iter(ctx, fn, coreTrans, coreTable) {\n    const filter = ctx.replayFilter ? combine(ctx.filter, ctx.replayFilter()) : ctx.filter;\n    if (!ctx.or) {\n        return iterate(openCursor(ctx, coreTable, coreTrans), combine(ctx.algorithm, filter), fn, !ctx.keysOnly && ctx.valueMapper);\n    }\n    else {\n        const set = {};\n        const union = (item, cursor, advance) => {\n            if (!filter || filter(cursor, advance, result => cursor.stop(result), err => cursor.fail(err))) {\n                var primaryKey = cursor.primaryKey;\n                var key = '' + primaryKey;\n                if (key === '[object ArrayBuffer]')\n                    key = '' + new Uint8Array(primaryKey);\n                if (!hasOwn(set, key)) {\n                    set[key] = true;\n                    fn(item, cursor, advance);\n                }\n            }\n        };\n        return Promise.all([\n            ctx.or._iterate(union, coreTrans),\n            iterate(openCursor(ctx, coreTable, coreTrans), ctx.algorithm, union, !ctx.keysOnly && ctx.valueMapper)\n        ]);\n    }\n}\nfunction iterate(cursorPromise, filter, fn, valueMapper) {\n    var mappedFn = valueMapper ? (x, c, a) => fn(valueMapper(x), c, a) : fn;\n    var wrappedFn = wrap(mappedFn);\n    return cursorPromise.then(cursor => {\n        if (cursor) {\n            return cursor.start(() => {\n                var c = () => cursor.continue();\n                if (!filter || filter(cursor, advancer => c = advancer, val => { cursor.stop(val); c = nop; }, e => { cursor.fail(e); c = nop; }))\n                    wrappedFn(cursor.value, cursor, advancer => c = advancer);\n                c();\n            });\n        }\n    });\n}\n\nfunction cmp(a, b) {\n    try {\n        const ta = type(a);\n        const tb = type(b);\n        if (ta !== tb) {\n            if (ta === 'Array')\n                return 1;\n            if (tb === 'Array')\n                return -1;\n            if (ta === 'binary')\n                return 1;\n            if (tb === 'binary')\n                return -1;\n            if (ta === 'string')\n                return 1;\n            if (tb === 'string')\n                return -1;\n            if (ta === 'Date')\n                return 1;\n            if (tb !== 'Date')\n                return NaN;\n            return -1;\n        }\n        switch (ta) {\n            case 'number':\n            case 'Date':\n            case 'string':\n                return a > b ? 1 : a < b ? -1 : 0;\n            case 'binary': {\n                return compareUint8Arrays(getUint8Array(a), getUint8Array(b));\n            }\n            case 'Array':\n                return compareArrays(a, b);\n        }\n    }\n    catch (_a) { }\n    return NaN;\n}\nfunction compareArrays(a, b) {\n    const al = a.length;\n    const bl = b.length;\n    const l = al < bl ? al : bl;\n    for (let i = 0; i < l; ++i) {\n        const res = cmp(a[i], b[i]);\n        if (res !== 0)\n            return res;\n    }\n    return al === bl ? 0 : al < bl ? -1 : 1;\n}\nfunction compareUint8Arrays(a, b) {\n    const al = a.length;\n    const bl = b.length;\n    const l = al < bl ? al : bl;\n    for (let i = 0; i < l; ++i) {\n        if (a[i] !== b[i])\n            return a[i] < b[i] ? -1 : 1;\n    }\n    return al === bl ? 0 : al < bl ? -1 : 1;\n}\nfunction type(x) {\n    const t = typeof x;\n    if (t !== 'object')\n        return t;\n    if (ArrayBuffer.isView(x))\n        return 'binary';\n    const tsTag = toStringTag(x);\n    return tsTag === 'ArrayBuffer' ? 'binary' : tsTag;\n}\nfunction getUint8Array(a) {\n    if (a instanceof Uint8Array)\n        return a;\n    if (ArrayBuffer.isView(a))\n        return new Uint8Array(a.buffer, a.byteOffset, a.byteLength);\n    return new Uint8Array(a);\n}\n\nclass Collection {\n    _read(fn, cb) {\n        var ctx = this._ctx;\n        return ctx.error ?\n            ctx.table._trans(null, rejection.bind(null, ctx.error)) :\n            ctx.table._trans('readonly', fn).then(cb);\n    }\n    _write(fn) {\n        var ctx = this._ctx;\n        return ctx.error ?\n            ctx.table._trans(null, rejection.bind(null, ctx.error)) :\n            ctx.table._trans('readwrite', fn, \"locked\");\n    }\n    _addAlgorithm(fn) {\n        var ctx = this._ctx;\n        ctx.algorithm = combine(ctx.algorithm, fn);\n    }\n    _iterate(fn, coreTrans) {\n        return iter(this._ctx, fn, coreTrans, this._ctx.table.core);\n    }\n    clone(props) {\n        var rv = Object.create(this.constructor.prototype), ctx = Object.create(this._ctx);\n        if (props)\n            extend(ctx, props);\n        rv._ctx = ctx;\n        return rv;\n    }\n    raw() {\n        this._ctx.valueMapper = null;\n        return this;\n    }\n    each(fn) {\n        var ctx = this._ctx;\n        return this._read(trans => iter(ctx, fn, trans, ctx.table.core));\n    }\n    count(cb) {\n        return this._read(trans => {\n            const ctx = this._ctx;\n            const coreTable = ctx.table.core;\n            if (isPlainKeyRange(ctx, true)) {\n                return coreTable.count({\n                    trans,\n                    query: {\n                        index: getIndexOrStore(ctx, coreTable.schema),\n                        range: ctx.range\n                    }\n                }).then(count => Math.min(count, ctx.limit));\n            }\n            else {\n                var count = 0;\n                return iter(ctx, () => { ++count; return false; }, trans, coreTable)\n                    .then(() => count);\n            }\n        }).then(cb);\n    }\n    sortBy(keyPath, cb) {\n        const parts = keyPath.split('.').reverse(), lastPart = parts[0], lastIndex = parts.length - 1;\n        function getval(obj, i) {\n            if (i)\n                return getval(obj[parts[i]], i - 1);\n            return obj[lastPart];\n        }\n        var order = this._ctx.dir === \"next\" ? 1 : -1;\n        function sorter(a, b) {\n            var aVal = getval(a, lastIndex), bVal = getval(b, lastIndex);\n            return aVal < bVal ? -order : aVal > bVal ? order : 0;\n        }\n        return this.toArray(function (a) {\n            return a.sort(sorter);\n        }).then(cb);\n    }\n    toArray(cb) {\n        return this._read(trans => {\n            var ctx = this._ctx;\n            if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {\n                const { valueMapper } = ctx;\n                const index = getIndexOrStore(ctx, ctx.table.core.schema);\n                return ctx.table.core.query({\n                    trans,\n                    limit: ctx.limit,\n                    values: true,\n                    query: {\n                        index,\n                        range: ctx.range\n                    }\n                }).then(({ result }) => valueMapper ? result.map(valueMapper) : result);\n            }\n            else {\n                const a = [];\n                return iter(ctx, item => a.push(item), trans, ctx.table.core).then(() => a);\n            }\n        }, cb);\n    }\n    offset(offset) {\n        var ctx = this._ctx;\n        if (offset <= 0)\n            return this;\n        ctx.offset += offset;\n        if (isPlainKeyRange(ctx)) {\n            addReplayFilter(ctx, () => {\n                var offsetLeft = offset;\n                return (cursor, advance) => {\n                    if (offsetLeft === 0)\n                        return true;\n                    if (offsetLeft === 1) {\n                        --offsetLeft;\n                        return false;\n                    }\n                    advance(() => {\n                        cursor.advance(offsetLeft);\n                        offsetLeft = 0;\n                    });\n                    return false;\n                };\n            });\n        }\n        else {\n            addReplayFilter(ctx, () => {\n                var offsetLeft = offset;\n                return () => (--offsetLeft < 0);\n            });\n        }\n        return this;\n    }\n    limit(numRows) {\n        this._ctx.limit = Math.min(this._ctx.limit, numRows);\n        addReplayFilter(this._ctx, () => {\n            var rowsLeft = numRows;\n            return function (cursor, advance, resolve) {\n                if (--rowsLeft <= 0)\n                    advance(resolve);\n                return rowsLeft >= 0;\n            };\n        }, true);\n        return this;\n    }\n    until(filterFunction, bIncludeStopEntry) {\n        addFilter(this._ctx, function (cursor, advance, resolve) {\n            if (filterFunction(cursor.value)) {\n                advance(resolve);\n                return bIncludeStopEntry;\n            }\n            else {\n                return true;\n            }\n        });\n        return this;\n    }\n    first(cb) {\n        return this.limit(1).toArray(function (a) { return a[0]; }).then(cb);\n    }\n    last(cb) {\n        return this.reverse().first(cb);\n    }\n    filter(filterFunction) {\n        addFilter(this._ctx, function (cursor) {\n            return filterFunction(cursor.value);\n        });\n        addMatchFilter(this._ctx, filterFunction);\n        return this;\n    }\n    and(filter) {\n        return this.filter(filter);\n    }\n    or(indexName) {\n        return new this.db.WhereClause(this._ctx.table, indexName, this);\n    }\n    reverse() {\n        this._ctx.dir = (this._ctx.dir === \"prev\" ? \"next\" : \"prev\");\n        if (this._ondirectionchange)\n            this._ondirectionchange(this._ctx.dir);\n        return this;\n    }\n    desc() {\n        return this.reverse();\n    }\n    eachKey(cb) {\n        var ctx = this._ctx;\n        ctx.keysOnly = !ctx.isMatch;\n        return this.each(function (val, cursor) { cb(cursor.key, cursor); });\n    }\n    eachUniqueKey(cb) {\n        this._ctx.unique = \"unique\";\n        return this.eachKey(cb);\n    }\n    eachPrimaryKey(cb) {\n        var ctx = this._ctx;\n        ctx.keysOnly = !ctx.isMatch;\n        return this.each(function (val, cursor) { cb(cursor.primaryKey, cursor); });\n    }\n    keys(cb) {\n        var ctx = this._ctx;\n        ctx.keysOnly = !ctx.isMatch;\n        var a = [];\n        return this.each(function (item, cursor) {\n            a.push(cursor.key);\n        }).then(function () {\n            return a;\n        }).then(cb);\n    }\n    primaryKeys(cb) {\n        var ctx = this._ctx;\n        if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {\n            return this._read(trans => {\n                var index = getIndexOrStore(ctx, ctx.table.core.schema);\n                return ctx.table.core.query({\n                    trans,\n                    values: false,\n                    limit: ctx.limit,\n                    query: {\n                        index,\n                        range: ctx.range\n                    }\n                });\n            }).then(({ result }) => result).then(cb);\n        }\n        ctx.keysOnly = !ctx.isMatch;\n        var a = [];\n        return this.each(function (item, cursor) {\n            a.push(cursor.primaryKey);\n        }).then(function () {\n            return a;\n        }).then(cb);\n    }\n    uniqueKeys(cb) {\n        this._ctx.unique = \"unique\";\n        return this.keys(cb);\n    }\n    firstKey(cb) {\n        return this.limit(1).keys(function (a) { return a[0]; }).then(cb);\n    }\n    lastKey(cb) {\n        return this.reverse().firstKey(cb);\n    }\n    distinct() {\n        var ctx = this._ctx, idx = ctx.index && ctx.table.schema.idxByName[ctx.index];\n        if (!idx || !idx.multi)\n            return this;\n        var set = {};\n        addFilter(this._ctx, function (cursor) {\n            var strKey = cursor.primaryKey.toString();\n            var found = hasOwn(set, strKey);\n            set[strKey] = true;\n            return !found;\n        });\n        return this;\n    }\n    modify(changes) {\n        var ctx = this._ctx;\n        return this._write(trans => {\n            var modifyer;\n            if (typeof changes === 'function') {\n                modifyer = changes;\n            }\n            else {\n                var keyPaths = keys(changes);\n                var numKeys = keyPaths.length;\n                modifyer = function (item) {\n                    var anythingModified = false;\n                    for (var i = 0; i < numKeys; ++i) {\n                        var keyPath = keyPaths[i], val = changes[keyPath];\n                        if (getByKeyPath(item, keyPath) !== val) {\n                            setByKeyPath(item, keyPath, val);\n                            anythingModified = true;\n                        }\n                    }\n                    return anythingModified;\n                };\n            }\n            const coreTable = ctx.table.core;\n            const { outbound, extractKey } = coreTable.schema.primaryKey;\n            const limit = this.db._options.modifyChunkSize || 200;\n            const totalFailures = [];\n            let successCount = 0;\n            const failedKeys = [];\n            const applyMutateResult = (expectedCount, res) => {\n                const { failures, numFailures } = res;\n                successCount += expectedCount - numFailures;\n                for (let pos of keys(failures)) {\n                    totalFailures.push(failures[pos]);\n                }\n            };\n            return this.clone().primaryKeys().then(keys => {\n                const nextChunk = (offset) => {\n                    const count = Math.min(limit, keys.length - offset);\n                    return coreTable.getMany({\n                        trans,\n                        keys: keys.slice(offset, offset + count),\n                        cache: \"immutable\"\n                    }).then(values => {\n                        const addValues = [];\n                        const putValues = [];\n                        const putKeys = outbound ? [] : null;\n                        const deleteKeys = [];\n                        for (let i = 0; i < count; ++i) {\n                            const origValue = values[i];\n                            const ctx = {\n                                value: deepClone(origValue),\n                                primKey: keys[offset + i]\n                            };\n                            if (modifyer.call(ctx, ctx.value, ctx) !== false) {\n                                if (ctx.value == null) {\n                                    deleteKeys.push(keys[offset + i]);\n                                }\n                                else if (!outbound && cmp(extractKey(origValue), extractKey(ctx.value)) !== 0) {\n                                    deleteKeys.push(keys[offset + i]);\n                                    addValues.push(ctx.value);\n                                }\n                                else {\n                                    putValues.push(ctx.value);\n                                    if (outbound)\n                                        putKeys.push(keys[offset + i]);\n                                }\n                            }\n                        }\n                        const criteria = isPlainKeyRange(ctx) &&\n                            ctx.limit === Infinity &&\n                            (typeof changes !== 'function' || changes === deleteCallback) && {\n                            index: ctx.index,\n                            range: ctx.range\n                        };\n                        return Promise.resolve(addValues.length > 0 &&\n                            coreTable.mutate({ trans, type: 'add', values: addValues })\n                                .then(res => {\n                                for (let pos in res.failures) {\n                                    deleteKeys.splice(parseInt(pos), 1);\n                                }\n                                applyMutateResult(addValues.length, res);\n                            })).then(() => (putValues.length > 0 || (criteria && typeof changes === 'object')) &&\n                            coreTable.mutate({\n                                trans,\n                                type: 'put',\n                                keys: putKeys,\n                                values: putValues,\n                                criteria,\n                                changeSpec: typeof changes !== 'function'\n                                    && changes\n                            }).then(res => applyMutateResult(putValues.length, res))).then(() => (deleteKeys.length > 0 || (criteria && changes === deleteCallback)) &&\n                            coreTable.mutate({\n                                trans,\n                                type: 'delete',\n                                keys: deleteKeys,\n                                criteria\n                            }).then(res => applyMutateResult(deleteKeys.length, res))).then(() => {\n                            return keys.length > offset + count && nextChunk(offset + limit);\n                        });\n                    });\n                };\n                return nextChunk(0).then(() => {\n                    if (totalFailures.length > 0)\n                        throw new ModifyError(\"Error modifying one or more objects\", totalFailures, successCount, failedKeys);\n                    return keys.length;\n                });\n            });\n        });\n    }\n    delete() {\n        var ctx = this._ctx, range = ctx.range;\n        if (isPlainKeyRange(ctx) &&\n            ((ctx.isPrimKey && !hangsOnDeleteLargeKeyRange) || range.type === 3 ))\n         {\n            return this._write(trans => {\n                const { primaryKey } = ctx.table.core.schema;\n                const coreRange = range;\n                return ctx.table.core.count({ trans, query: { index: primaryKey, range: coreRange } }).then(count => {\n                    return ctx.table.core.mutate({ trans, type: 'deleteRange', range: coreRange })\n                        .then(({ failures, lastResult, results, numFailures }) => {\n                        if (numFailures)\n                            throw new ModifyError(\"Could not delete some values\", Object.keys(failures).map(pos => failures[pos]), count - numFailures);\n                        return count - numFailures;\n                    });\n                });\n            });\n        }\n        return this.modify(deleteCallback);\n    }\n}\nconst deleteCallback = (value, ctx) => ctx.value = null;\n\nfunction createCollectionConstructor(db) {\n    return makeClassConstructor(Collection.prototype, function Collection(whereClause, keyRangeGenerator) {\n        this.db = db;\n        let keyRange = AnyRange, error = null;\n        if (keyRangeGenerator)\n            try {\n                keyRange = keyRangeGenerator();\n            }\n            catch (ex) {\n                error = ex;\n            }\n        const whereCtx = whereClause._ctx;\n        const table = whereCtx.table;\n        const readingHook = table.hook.reading.fire;\n        this._ctx = {\n            table: table,\n            index: whereCtx.index,\n            isPrimKey: (!whereCtx.index || (table.schema.primKey.keyPath && whereCtx.index === table.schema.primKey.name)),\n            range: keyRange,\n            keysOnly: false,\n            dir: \"next\",\n            unique: \"\",\n            algorithm: null,\n            filter: null,\n            replayFilter: null,\n            justLimit: true,\n            isMatch: null,\n            offset: 0,\n            limit: Infinity,\n            error: error,\n            or: whereCtx.or,\n            valueMapper: readingHook !== mirror ? readingHook : null\n        };\n    });\n}\n\nfunction simpleCompare(a, b) {\n    return a < b ? -1 : a === b ? 0 : 1;\n}\nfunction simpleCompareReverse(a, b) {\n    return a > b ? -1 : a === b ? 0 : 1;\n}\n\nfunction fail(collectionOrWhereClause, err, T) {\n    var collection = collectionOrWhereClause instanceof WhereClause ?\n        new collectionOrWhereClause.Collection(collectionOrWhereClause) :\n        collectionOrWhereClause;\n    collection._ctx.error = T ? new T(err) : new TypeError(err);\n    return collection;\n}\nfunction emptyCollection(whereClause) {\n    return new whereClause.Collection(whereClause, () => rangeEqual(\"\")).limit(0);\n}\nfunction upperFactory(dir) {\n    return dir === \"next\" ?\n        (s) => s.toUpperCase() :\n        (s) => s.toLowerCase();\n}\nfunction lowerFactory(dir) {\n    return dir === \"next\" ?\n        (s) => s.toLowerCase() :\n        (s) => s.toUpperCase();\n}\nfunction nextCasing(key, lowerKey, upperNeedle, lowerNeedle, cmp, dir) {\n    var length = Math.min(key.length, lowerNeedle.length);\n    var llp = -1;\n    for (var i = 0; i < length; ++i) {\n        var lwrKeyChar = lowerKey[i];\n        if (lwrKeyChar !== lowerNeedle[i]) {\n            if (cmp(key[i], upperNeedle[i]) < 0)\n                return key.substr(0, i) + upperNeedle[i] + upperNeedle.substr(i + 1);\n            if (cmp(key[i], lowerNeedle[i]) < 0)\n                return key.substr(0, i) + lowerNeedle[i] + upperNeedle.substr(i + 1);\n            if (llp >= 0)\n                return key.substr(0, llp) + lowerKey[llp] + upperNeedle.substr(llp + 1);\n            return null;\n        }\n        if (cmp(key[i], lwrKeyChar) < 0)\n            llp = i;\n    }\n    if (length < lowerNeedle.length && dir === \"next\")\n        return key + upperNeedle.substr(key.length);\n    if (length < key.length && dir === \"prev\")\n        return key.substr(0, upperNeedle.length);\n    return (llp < 0 ? null : key.substr(0, llp) + lowerNeedle[llp] + upperNeedle.substr(llp + 1));\n}\nfunction addIgnoreCaseAlgorithm(whereClause, match, needles, suffix) {\n    var upper, lower, compare, upperNeedles, lowerNeedles, direction, nextKeySuffix, needlesLen = needles.length;\n    if (!needles.every(s => typeof s === 'string')) {\n        return fail(whereClause, STRING_EXPECTED);\n    }\n    function initDirection(dir) {\n        upper = upperFactory(dir);\n        lower = lowerFactory(dir);\n        compare = (dir === \"next\" ? simpleCompare : simpleCompareReverse);\n        var needleBounds = needles.map(function (needle) {\n            return { lower: lower(needle), upper: upper(needle) };\n        }).sort(function (a, b) {\n            return compare(a.lower, b.lower);\n        });\n        upperNeedles = needleBounds.map(function (nb) { return nb.upper; });\n        lowerNeedles = needleBounds.map(function (nb) { return nb.lower; });\n        direction = dir;\n        nextKeySuffix = (dir === \"next\" ? \"\" : suffix);\n    }\n    initDirection(\"next\");\n    var c = new whereClause.Collection(whereClause, () => createRange(upperNeedles[0], lowerNeedles[needlesLen - 1] + suffix));\n    c._ondirectionchange = function (direction) {\n        initDirection(direction);\n    };\n    var firstPossibleNeedle = 0;\n    c._addAlgorithm(function (cursor, advance, resolve) {\n        var key = cursor.key;\n        if (typeof key !== 'string')\n            return false;\n        var lowerKey = lower(key);\n        if (match(lowerKey, lowerNeedles, firstPossibleNeedle)) {\n            return true;\n        }\n        else {\n            var lowestPossibleCasing = null;\n            for (var i = firstPossibleNeedle; i < needlesLen; ++i) {\n                var casing = nextCasing(key, lowerKey, upperNeedles[i], lowerNeedles[i], compare, direction);\n                if (casing === null && lowestPossibleCasing === null)\n                    firstPossibleNeedle = i + 1;\n                else if (lowestPossibleCasing === null || compare(lowestPossibleCasing, casing) > 0) {\n                    lowestPossibleCasing = casing;\n                }\n            }\n            if (lowestPossibleCasing !== null) {\n                advance(function () { cursor.continue(lowestPossibleCasing + nextKeySuffix); });\n            }\n            else {\n                advance(resolve);\n            }\n            return false;\n        }\n    });\n    return c;\n}\nfunction createRange(lower, upper, lowerOpen, upperOpen) {\n    return {\n        type: 2 ,\n        lower,\n        upper,\n        lowerOpen,\n        upperOpen\n    };\n}\nfunction rangeEqual(value) {\n    return {\n        type: 1 ,\n        lower: value,\n        upper: value\n    };\n}\n\nclass WhereClause {\n    get Collection() {\n        return this._ctx.table.db.Collection;\n    }\n    between(lower, upper, includeLower, includeUpper) {\n        includeLower = includeLower !== false;\n        includeUpper = includeUpper === true;\n        try {\n            if ((this._cmp(lower, upper) > 0) ||\n                (this._cmp(lower, upper) === 0 && (includeLower || includeUpper) && !(includeLower && includeUpper)))\n                return emptyCollection(this);\n            return new this.Collection(this, () => createRange(lower, upper, !includeLower, !includeUpper));\n        }\n        catch (e) {\n            return fail(this, INVALID_KEY_ARGUMENT);\n        }\n    }\n    equals(value) {\n        if (value == null)\n            return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, () => rangeEqual(value));\n    }\n    above(value) {\n        if (value == null)\n            return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, () => createRange(value, undefined, true));\n    }\n    aboveOrEqual(value) {\n        if (value == null)\n            return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, () => createRange(value, undefined, false));\n    }\n    below(value) {\n        if (value == null)\n            return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, () => createRange(undefined, value, false, true));\n    }\n    belowOrEqual(value) {\n        if (value == null)\n            return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, () => createRange(undefined, value));\n    }\n    startsWith(str) {\n        if (typeof str !== 'string')\n            return fail(this, STRING_EXPECTED);\n        return this.between(str, str + maxString, true, true);\n    }\n    startsWithIgnoreCase(str) {\n        if (str === \"\")\n            return this.startsWith(str);\n        return addIgnoreCaseAlgorithm(this, (x, a) => x.indexOf(a[0]) === 0, [str], maxString);\n    }\n    equalsIgnoreCase(str) {\n        return addIgnoreCaseAlgorithm(this, (x, a) => x === a[0], [str], \"\");\n    }\n    anyOfIgnoreCase() {\n        var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        if (set.length === 0)\n            return emptyCollection(this);\n        return addIgnoreCaseAlgorithm(this, (x, a) => a.indexOf(x) !== -1, set, \"\");\n    }\n    startsWithAnyOfIgnoreCase() {\n        var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        if (set.length === 0)\n            return emptyCollection(this);\n        return addIgnoreCaseAlgorithm(this, (x, a) => a.some(n => x.indexOf(n) === 0), set, maxString);\n    }\n    anyOf() {\n        const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        let compare = this._cmp;\n        try {\n            set.sort(compare);\n        }\n        catch (e) {\n            return fail(this, INVALID_KEY_ARGUMENT);\n        }\n        if (set.length === 0)\n            return emptyCollection(this);\n        const c = new this.Collection(this, () => createRange(set[0], set[set.length - 1]));\n        c._ondirectionchange = direction => {\n            compare = (direction === \"next\" ?\n                this._ascending :\n                this._descending);\n            set.sort(compare);\n        };\n        let i = 0;\n        c._addAlgorithm((cursor, advance, resolve) => {\n            const key = cursor.key;\n            while (compare(key, set[i]) > 0) {\n                ++i;\n                if (i === set.length) {\n                    advance(resolve);\n                    return false;\n                }\n            }\n            if (compare(key, set[i]) === 0) {\n                return true;\n            }\n            else {\n                advance(() => { cursor.continue(set[i]); });\n                return false;\n            }\n        });\n        return c;\n    }\n    notEqual(value) {\n        return this.inAnyRange([[minKey, value], [value, this.db._maxKey]], { includeLowers: false, includeUppers: false });\n    }\n    noneOf() {\n        const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        if (set.length === 0)\n            return new this.Collection(this);\n        try {\n            set.sort(this._ascending);\n        }\n        catch (e) {\n            return fail(this, INVALID_KEY_ARGUMENT);\n        }\n        const ranges = set.reduce((res, val) => res ?\n            res.concat([[res[res.length - 1][1], val]]) :\n            [[minKey, val]], null);\n        ranges.push([set[set.length - 1], this.db._maxKey]);\n        return this.inAnyRange(ranges, { includeLowers: false, includeUppers: false });\n    }\n    inAnyRange(ranges, options) {\n        const cmp = this._cmp, ascending = this._ascending, descending = this._descending, min = this._min, max = this._max;\n        if (ranges.length === 0)\n            return emptyCollection(this);\n        if (!ranges.every(range => range[0] !== undefined &&\n            range[1] !== undefined &&\n            ascending(range[0], range[1]) <= 0)) {\n            return fail(this, \"First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower\", exceptions.InvalidArgument);\n        }\n        const includeLowers = !options || options.includeLowers !== false;\n        const includeUppers = options && options.includeUppers === true;\n        function addRange(ranges, newRange) {\n            let i = 0, l = ranges.length;\n            for (; i < l; ++i) {\n                const range = ranges[i];\n                if (cmp(newRange[0], range[1]) < 0 && cmp(newRange[1], range[0]) > 0) {\n                    range[0] = min(range[0], newRange[0]);\n                    range[1] = max(range[1], newRange[1]);\n                    break;\n                }\n            }\n            if (i === l)\n                ranges.push(newRange);\n            return ranges;\n        }\n        let sortDirection = ascending;\n        function rangeSorter(a, b) { return sortDirection(a[0], b[0]); }\n        let set;\n        try {\n            set = ranges.reduce(addRange, []);\n            set.sort(rangeSorter);\n        }\n        catch (ex) {\n            return fail(this, INVALID_KEY_ARGUMENT);\n        }\n        let rangePos = 0;\n        const keyIsBeyondCurrentEntry = includeUppers ?\n            key => ascending(key, set[rangePos][1]) > 0 :\n            key => ascending(key, set[rangePos][1]) >= 0;\n        const keyIsBeforeCurrentEntry = includeLowers ?\n            key => descending(key, set[rangePos][0]) > 0 :\n            key => descending(key, set[rangePos][0]) >= 0;\n        function keyWithinCurrentRange(key) {\n            return !keyIsBeyondCurrentEntry(key) && !keyIsBeforeCurrentEntry(key);\n        }\n        let checkKey = keyIsBeyondCurrentEntry;\n        const c = new this.Collection(this, () => createRange(set[0][0], set[set.length - 1][1], !includeLowers, !includeUppers));\n        c._ondirectionchange = direction => {\n            if (direction === \"next\") {\n                checkKey = keyIsBeyondCurrentEntry;\n                sortDirection = ascending;\n            }\n            else {\n                checkKey = keyIsBeforeCurrentEntry;\n                sortDirection = descending;\n            }\n            set.sort(rangeSorter);\n        };\n        c._addAlgorithm((cursor, advance, resolve) => {\n            var key = cursor.key;\n            while (checkKey(key)) {\n                ++rangePos;\n                if (rangePos === set.length) {\n                    advance(resolve);\n                    return false;\n                }\n            }\n            if (keyWithinCurrentRange(key)) {\n                return true;\n            }\n            else if (this._cmp(key, set[rangePos][1]) === 0 || this._cmp(key, set[rangePos][0]) === 0) {\n                return false;\n            }\n            else {\n                advance(() => {\n                    if (sortDirection === ascending)\n                        cursor.continue(set[rangePos][0]);\n                    else\n                        cursor.continue(set[rangePos][1]);\n                });\n                return false;\n            }\n        });\n        return c;\n    }\n    startsWithAnyOf() {\n        const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        if (!set.every(s => typeof s === 'string')) {\n            return fail(this, \"startsWithAnyOf() only works with strings\");\n        }\n        if (set.length === 0)\n            return emptyCollection(this);\n        return this.inAnyRange(set.map((str) => [str, str + maxString]));\n    }\n}\n\nfunction createWhereClauseConstructor(db) {\n    return makeClassConstructor(WhereClause.prototype, function WhereClause(table, index, orCollection) {\n        this.db = db;\n        this._ctx = {\n            table: table,\n            index: index === \":id\" ? null : index,\n            or: orCollection\n        };\n        const indexedDB = db._deps.indexedDB;\n        if (!indexedDB)\n            throw new exceptions.MissingAPI();\n        this._cmp = this._ascending = indexedDB.cmp.bind(indexedDB);\n        this._descending = (a, b) => indexedDB.cmp(b, a);\n        this._max = (a, b) => indexedDB.cmp(a, b) > 0 ? a : b;\n        this._min = (a, b) => indexedDB.cmp(a, b) < 0 ? a : b;\n        this._IDBKeyRange = db._deps.IDBKeyRange;\n    });\n}\n\nfunction eventRejectHandler(reject) {\n    return wrap(function (event) {\n        preventDefault(event);\n        reject(event.target.error);\n        return false;\n    });\n}\nfunction preventDefault(event) {\n    if (event.stopPropagation)\n        event.stopPropagation();\n    if (event.preventDefault)\n        event.preventDefault();\n}\n\nconst DEXIE_STORAGE_MUTATED_EVENT_NAME = 'storagemutated';\nconst STORAGE_MUTATED_DOM_EVENT_NAME = 'x-storagemutated-1';\nconst globalEvents = Events(null, DEXIE_STORAGE_MUTATED_EVENT_NAME);\n\nclass Transaction {\n    _lock() {\n        assert(!PSD.global);\n        ++this._reculock;\n        if (this._reculock === 1 && !PSD.global)\n            PSD.lockOwnerFor = this;\n        return this;\n    }\n    _unlock() {\n        assert(!PSD.global);\n        if (--this._reculock === 0) {\n            if (!PSD.global)\n                PSD.lockOwnerFor = null;\n            while (this._blockedFuncs.length > 0 && !this._locked()) {\n                var fnAndPSD = this._blockedFuncs.shift();\n                try {\n                    usePSD(fnAndPSD[1], fnAndPSD[0]);\n                }\n                catch (e) { }\n            }\n        }\n        return this;\n    }\n    _locked() {\n        return this._reculock && PSD.lockOwnerFor !== this;\n    }\n    create(idbtrans) {\n        if (!this.mode)\n            return this;\n        const idbdb = this.db.idbdb;\n        const dbOpenError = this.db._state.dbOpenError;\n        assert(!this.idbtrans);\n        if (!idbtrans && !idbdb) {\n            switch (dbOpenError && dbOpenError.name) {\n                case \"DatabaseClosedError\":\n                    throw new exceptions.DatabaseClosed(dbOpenError);\n                case \"MissingAPIError\":\n                    throw new exceptions.MissingAPI(dbOpenError.message, dbOpenError);\n                default:\n                    throw new exceptions.OpenFailed(dbOpenError);\n            }\n        }\n        if (!this.active)\n            throw new exceptions.TransactionInactive();\n        assert(this._completion._state === null);\n        idbtrans = this.idbtrans = idbtrans ||\n            (this.db.core\n                ? this.db.core.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })\n                : idbdb.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }));\n        idbtrans.onerror = wrap(ev => {\n            preventDefault(ev);\n            this._reject(idbtrans.error);\n        });\n        idbtrans.onabort = wrap(ev => {\n            preventDefault(ev);\n            this.active && this._reject(new exceptions.Abort(idbtrans.error));\n            this.active = false;\n            this.on(\"abort\").fire(ev);\n        });\n        idbtrans.oncomplete = wrap(() => {\n            this.active = false;\n            this._resolve();\n            if ('mutatedParts' in idbtrans) {\n                globalEvents.storagemutated.fire(idbtrans[\"mutatedParts\"]);\n            }\n        });\n        return this;\n    }\n    _promise(mode, fn, bWriteLock) {\n        if (mode === 'readwrite' && this.mode !== 'readwrite')\n            return rejection(new exceptions.ReadOnly(\"Transaction is readonly\"));\n        if (!this.active)\n            return rejection(new exceptions.TransactionInactive());\n        if (this._locked()) {\n            return new DexiePromise((resolve, reject) => {\n                this._blockedFuncs.push([() => {\n                        this._promise(mode, fn, bWriteLock).then(resolve, reject);\n                    }, PSD]);\n            });\n        }\n        else if (bWriteLock) {\n            return newScope(() => {\n                var p = new DexiePromise((resolve, reject) => {\n                    this._lock();\n                    const rv = fn(resolve, reject, this);\n                    if (rv && rv.then)\n                        rv.then(resolve, reject);\n                });\n                p.finally(() => this._unlock());\n                p._lib = true;\n                return p;\n            });\n        }\n        else {\n            var p = new DexiePromise((resolve, reject) => {\n                var rv = fn(resolve, reject, this);\n                if (rv && rv.then)\n                    rv.then(resolve, reject);\n            });\n            p._lib = true;\n            return p;\n        }\n    }\n    _root() {\n        return this.parent ? this.parent._root() : this;\n    }\n    waitFor(promiseLike) {\n        var root = this._root();\n        const promise = DexiePromise.resolve(promiseLike);\n        if (root._waitingFor) {\n            root._waitingFor = root._waitingFor.then(() => promise);\n        }\n        else {\n            root._waitingFor = promise;\n            root._waitingQueue = [];\n            var store = root.idbtrans.objectStore(root.storeNames[0]);\n            (function spin() {\n                ++root._spinCount;\n                while (root._waitingQueue.length)\n                    (root._waitingQueue.shift())();\n                if (root._waitingFor)\n                    store.get(-Infinity).onsuccess = spin;\n            }());\n        }\n        var currentWaitPromise = root._waitingFor;\n        return new DexiePromise((resolve, reject) => {\n            promise.then(res => root._waitingQueue.push(wrap(resolve.bind(null, res))), err => root._waitingQueue.push(wrap(reject.bind(null, err)))).finally(() => {\n                if (root._waitingFor === currentWaitPromise) {\n                    root._waitingFor = null;\n                }\n            });\n        });\n    }\n    abort() {\n        if (this.active) {\n            this.active = false;\n            if (this.idbtrans)\n                this.idbtrans.abort();\n            this._reject(new exceptions.Abort());\n        }\n    }\n    table(tableName) {\n        const memoizedTables = (this._memoizedTables || (this._memoizedTables = {}));\n        if (hasOwn(memoizedTables, tableName))\n            return memoizedTables[tableName];\n        const tableSchema = this.schema[tableName];\n        if (!tableSchema) {\n            throw new exceptions.NotFound(\"Table \" + tableName + \" not part of transaction\");\n        }\n        const transactionBoundTable = new this.db.Table(tableName, tableSchema, this);\n        transactionBoundTable.core = this.db.core.table(tableName);\n        memoizedTables[tableName] = transactionBoundTable;\n        return transactionBoundTable;\n    }\n}\n\nfunction createTransactionConstructor(db) {\n    return makeClassConstructor(Transaction.prototype, function Transaction(mode, storeNames, dbschema, chromeTransactionDurability, parent) {\n        this.db = db;\n        this.mode = mode;\n        this.storeNames = storeNames;\n        this.schema = dbschema;\n        this.chromeTransactionDurability = chromeTransactionDurability;\n        this.idbtrans = null;\n        this.on = Events(this, \"complete\", \"error\", \"abort\");\n        this.parent = parent || null;\n        this.active = true;\n        this._reculock = 0;\n        this._blockedFuncs = [];\n        this._resolve = null;\n        this._reject = null;\n        this._waitingFor = null;\n        this._waitingQueue = null;\n        this._spinCount = 0;\n        this._completion = new DexiePromise((resolve, reject) => {\n            this._resolve = resolve;\n            this._reject = reject;\n        });\n        this._completion.then(() => {\n            this.active = false;\n            this.on.complete.fire();\n        }, e => {\n            var wasActive = this.active;\n            this.active = false;\n            this.on.error.fire(e);\n            this.parent ?\n                this.parent._reject(e) :\n                wasActive && this.idbtrans && this.idbtrans.abort();\n            return rejection(e);\n        });\n    });\n}\n\nfunction createIndexSpec(name, keyPath, unique, multi, auto, compound, isPrimKey) {\n    return {\n        name,\n        keyPath,\n        unique,\n        multi,\n        auto,\n        compound,\n        src: (unique && !isPrimKey ? '&' : '') + (multi ? '*' : '') + (auto ? \"++\" : \"\") + nameFromKeyPath(keyPath)\n    };\n}\nfunction nameFromKeyPath(keyPath) {\n    return typeof keyPath === 'string' ?\n        keyPath :\n        keyPath ? ('[' + [].join.call(keyPath, '+') + ']') : \"\";\n}\n\nfunction createTableSchema(name, primKey, indexes) {\n    return {\n        name,\n        primKey,\n        indexes,\n        mappedClass: null,\n        idxByName: arrayToObject(indexes, index => [index.name, index])\n    };\n}\n\nfunction safariMultiStoreFix(storeNames) {\n    return storeNames.length === 1 ? storeNames[0] : storeNames;\n}\nlet getMaxKey = (IdbKeyRange) => {\n    try {\n        IdbKeyRange.only([[]]);\n        getMaxKey = () => [[]];\n        return [[]];\n    }\n    catch (e) {\n        getMaxKey = () => maxString;\n        return maxString;\n    }\n};\n\nfunction getKeyExtractor(keyPath) {\n    if (keyPath == null) {\n        return () => undefined;\n    }\n    else if (typeof keyPath === 'string') {\n        return getSinglePathKeyExtractor(keyPath);\n    }\n    else {\n        return obj => getByKeyPath(obj, keyPath);\n    }\n}\nfunction getSinglePathKeyExtractor(keyPath) {\n    const split = keyPath.split('.');\n    if (split.length === 1) {\n        return obj => obj[keyPath];\n    }\n    else {\n        return obj => getByKeyPath(obj, keyPath);\n    }\n}\n\nfunction arrayify(arrayLike) {\n    return [].slice.call(arrayLike);\n}\nlet _id_counter = 0;\nfunction getKeyPathAlias(keyPath) {\n    return keyPath == null ?\n        \":id\" :\n        typeof keyPath === 'string' ?\n            keyPath :\n            `[${keyPath.join('+')}]`;\n}\nfunction createDBCore(db, IdbKeyRange, tmpTrans) {\n    function extractSchema(db, trans) {\n        const tables = arrayify(db.objectStoreNames);\n        return {\n            schema: {\n                name: db.name,\n                tables: tables.map(table => trans.objectStore(table)).map(store => {\n                    const { keyPath, autoIncrement } = store;\n                    const compound = isArray(keyPath);\n                    const outbound = keyPath == null;\n                    const indexByKeyPath = {};\n                    const result = {\n                        name: store.name,\n                        primaryKey: {\n                            name: null,\n                            isPrimaryKey: true,\n                            outbound,\n                            compound,\n                            keyPath,\n                            autoIncrement,\n                            unique: true,\n                            extractKey: getKeyExtractor(keyPath)\n                        },\n                        indexes: arrayify(store.indexNames).map(indexName => store.index(indexName))\n                            .map(index => {\n                            const { name, unique, multiEntry, keyPath } = index;\n                            const compound = isArray(keyPath);\n                            const result = {\n                                name,\n                                compound,\n                                keyPath,\n                                unique,\n                                multiEntry,\n                                extractKey: getKeyExtractor(keyPath)\n                            };\n                            indexByKeyPath[getKeyPathAlias(keyPath)] = result;\n                            return result;\n                        }),\n                        getIndexByKeyPath: (keyPath) => indexByKeyPath[getKeyPathAlias(keyPath)]\n                    };\n                    indexByKeyPath[\":id\"] = result.primaryKey;\n                    if (keyPath != null) {\n                        indexByKeyPath[getKeyPathAlias(keyPath)] = result.primaryKey;\n                    }\n                    return result;\n                })\n            },\n            hasGetAll: tables.length > 0 && ('getAll' in trans.objectStore(tables[0])) &&\n                !(typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) &&\n                    !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) &&\n                    [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604)\n        };\n    }\n    function makeIDBKeyRange(range) {\n        if (range.type === 3 )\n            return null;\n        if (range.type === 4 )\n            throw new Error(\"Cannot convert never type to IDBKeyRange\");\n        const { lower, upper, lowerOpen, upperOpen } = range;\n        const idbRange = lower === undefined ?\n            upper === undefined ?\n                null :\n                IdbKeyRange.upperBound(upper, !!upperOpen) :\n            upper === undefined ?\n                IdbKeyRange.lowerBound(lower, !!lowerOpen) :\n                IdbKeyRange.bound(lower, upper, !!lowerOpen, !!upperOpen);\n        return idbRange;\n    }\n    function createDbCoreTable(tableSchema) {\n        const tableName = tableSchema.name;\n        function mutate({ trans, type, keys, values, range }) {\n            return new Promise((resolve, reject) => {\n                resolve = wrap(resolve);\n                const store = trans.objectStore(tableName);\n                const outbound = store.keyPath == null;\n                const isAddOrPut = type === \"put\" || type === \"add\";\n                if (!isAddOrPut && type !== 'delete' && type !== 'deleteRange')\n                    throw new Error(\"Invalid operation type: \" + type);\n                const { length } = keys || values || { length: 1 };\n                if (keys && values && keys.length !== values.length) {\n                    throw new Error(\"Given keys array must have same length as given values array.\");\n                }\n                if (length === 0)\n                    return resolve({ numFailures: 0, failures: {}, results: [], lastResult: undefined });\n                let req;\n                const reqs = [];\n                const failures = [];\n                let numFailures = 0;\n                const errorHandler = event => {\n                    ++numFailures;\n                    preventDefault(event);\n                };\n                if (type === 'deleteRange') {\n                    if (range.type === 4 )\n                        return resolve({ numFailures, failures, results: [], lastResult: undefined });\n                    if (range.type === 3 )\n                        reqs.push(req = store.clear());\n                    else\n                        reqs.push(req = store.delete(makeIDBKeyRange(range)));\n                }\n                else {\n                    const [args1, args2] = isAddOrPut ?\n                        outbound ?\n                            [values, keys] :\n                            [values, null] :\n                        [keys, null];\n                    if (isAddOrPut) {\n                        for (let i = 0; i < length; ++i) {\n                            reqs.push(req = (args2 && args2[i] !== undefined ?\n                                store[type](args1[i], args2[i]) :\n                                store[type](args1[i])));\n                            req.onerror = errorHandler;\n                        }\n                    }\n                    else {\n                        for (let i = 0; i < length; ++i) {\n                            reqs.push(req = store[type](args1[i]));\n                            req.onerror = errorHandler;\n                        }\n                    }\n                }\n                const done = event => {\n                    const lastResult = event.target.result;\n                    reqs.forEach((req, i) => req.error != null && (failures[i] = req.error));\n                    resolve({\n                        numFailures,\n                        failures,\n                        results: type === \"delete\" ? keys : reqs.map(req => req.result),\n                        lastResult\n                    });\n                };\n                req.onerror = event => {\n                    errorHandler(event);\n                    done(event);\n                };\n                req.onsuccess = done;\n            });\n        }\n        function openCursor({ trans, values, query, reverse, unique }) {\n            return new Promise((resolve, reject) => {\n                resolve = wrap(resolve);\n                const { index, range } = query;\n                const store = trans.objectStore(tableName);\n                const source = index.isPrimaryKey ?\n                    store :\n                    store.index(index.name);\n                const direction = reverse ?\n                    unique ?\n                        \"prevunique\" :\n                        \"prev\" :\n                    unique ?\n                        \"nextunique\" :\n                        \"next\";\n                const req = values || !('openKeyCursor' in source) ?\n                    source.openCursor(makeIDBKeyRange(range), direction) :\n                    source.openKeyCursor(makeIDBKeyRange(range), direction);\n                req.onerror = eventRejectHandler(reject);\n                req.onsuccess = wrap(ev => {\n                    const cursor = req.result;\n                    if (!cursor) {\n                        resolve(null);\n                        return;\n                    }\n                    cursor.___id = ++_id_counter;\n                    cursor.done = false;\n                    const _cursorContinue = cursor.continue.bind(cursor);\n                    let _cursorContinuePrimaryKey = cursor.continuePrimaryKey;\n                    if (_cursorContinuePrimaryKey)\n                        _cursorContinuePrimaryKey = _cursorContinuePrimaryKey.bind(cursor);\n                    const _cursorAdvance = cursor.advance.bind(cursor);\n                    const doThrowCursorIsNotStarted = () => { throw new Error(\"Cursor not started\"); };\n                    const doThrowCursorIsStopped = () => { throw new Error(\"Cursor not stopped\"); };\n                    cursor.trans = trans;\n                    cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsNotStarted;\n                    cursor.fail = wrap(reject);\n                    cursor.next = function () {\n                        let gotOne = 1;\n                        return this.start(() => gotOne-- ? this.continue() : this.stop()).then(() => this);\n                    };\n                    cursor.start = (callback) => {\n                        const iterationPromise = new Promise((resolveIteration, rejectIteration) => {\n                            resolveIteration = wrap(resolveIteration);\n                            req.onerror = eventRejectHandler(rejectIteration);\n                            cursor.fail = rejectIteration;\n                            cursor.stop = value => {\n                                cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsStopped;\n                                resolveIteration(value);\n                            };\n                        });\n                        const guardedCallback = () => {\n                            if (req.result) {\n                                try {\n                                    callback();\n                                }\n                                catch (err) {\n                                    cursor.fail(err);\n                                }\n                            }\n                            else {\n                                cursor.done = true;\n                                cursor.start = () => { throw new Error(\"Cursor behind last entry\"); };\n                                cursor.stop();\n                            }\n                        };\n                        req.onsuccess = wrap(ev => {\n                            req.onsuccess = guardedCallback;\n                            guardedCallback();\n                        });\n                        cursor.continue = _cursorContinue;\n                        cursor.continuePrimaryKey = _cursorContinuePrimaryKey;\n                        cursor.advance = _cursorAdvance;\n                        guardedCallback();\n                        return iterationPromise;\n                    };\n                    resolve(cursor);\n                }, reject);\n            });\n        }\n        function query(hasGetAll) {\n            return (request) => {\n                return new Promise((resolve, reject) => {\n                    resolve = wrap(resolve);\n                    const { trans, values, limit, query } = request;\n                    const nonInfinitLimit = limit === Infinity ? undefined : limit;\n                    const { index, range } = query;\n                    const store = trans.objectStore(tableName);\n                    const source = index.isPrimaryKey ? store : store.index(index.name);\n                    const idbKeyRange = makeIDBKeyRange(range);\n                    if (limit === 0)\n                        return resolve({ result: [] });\n                    if (hasGetAll) {\n                        const req = values ?\n                            source.getAll(idbKeyRange, nonInfinitLimit) :\n                            source.getAllKeys(idbKeyRange, nonInfinitLimit);\n                        req.onsuccess = event => resolve({ result: event.target.result });\n                        req.onerror = eventRejectHandler(reject);\n                    }\n                    else {\n                        let count = 0;\n                        const req = values || !('openKeyCursor' in source) ?\n                            source.openCursor(idbKeyRange) :\n                            source.openKeyCursor(idbKeyRange);\n                        const result = [];\n                        req.onsuccess = event => {\n                            const cursor = req.result;\n                            if (!cursor)\n                                return resolve({ result });\n                            result.push(values ? cursor.value : cursor.primaryKey);\n                            if (++count === limit)\n                                return resolve({ result });\n                            cursor.continue();\n                        };\n                        req.onerror = eventRejectHandler(reject);\n                    }\n                });\n            };\n        }\n        return {\n            name: tableName,\n            schema: tableSchema,\n            mutate,\n            getMany({ trans, keys }) {\n                return new Promise((resolve, reject) => {\n                    resolve = wrap(resolve);\n                    const store = trans.objectStore(tableName);\n                    const length = keys.length;\n                    const result = new Array(length);\n                    let keyCount = 0;\n                    let callbackCount = 0;\n                    let req;\n                    const successHandler = event => {\n                        const req = event.target;\n                        if ((result[req._pos] = req.result) != null)\n                            ;\n                        if (++callbackCount === keyCount)\n                            resolve(result);\n                    };\n                    const errorHandler = eventRejectHandler(reject);\n                    for (let i = 0; i < length; ++i) {\n                        const key = keys[i];\n                        if (key != null) {\n                            req = store.get(keys[i]);\n                            req._pos = i;\n                            req.onsuccess = successHandler;\n                            req.onerror = errorHandler;\n                            ++keyCount;\n                        }\n                    }\n                    if (keyCount === 0)\n                        resolve(result);\n                });\n            },\n            get({ trans, key }) {\n                return new Promise((resolve, reject) => {\n                    resolve = wrap(resolve);\n                    const store = trans.objectStore(tableName);\n                    const req = store.get(key);\n                    req.onsuccess = event => resolve(event.target.result);\n                    req.onerror = eventRejectHandler(reject);\n                });\n            },\n            query: query(hasGetAll),\n            openCursor,\n            count({ query, trans }) {\n                const { index, range } = query;\n                return new Promise((resolve, reject) => {\n                    const store = trans.objectStore(tableName);\n                    const source = index.isPrimaryKey ? store : store.index(index.name);\n                    const idbKeyRange = makeIDBKeyRange(range);\n                    const req = idbKeyRange ? source.count(idbKeyRange) : source.count();\n                    req.onsuccess = wrap(ev => resolve(ev.target.result));\n                    req.onerror = eventRejectHandler(reject);\n                });\n            }\n        };\n    }\n    const { schema, hasGetAll } = extractSchema(db, tmpTrans);\n    const tables = schema.tables.map(tableSchema => createDbCoreTable(tableSchema));\n    const tableMap = {};\n    tables.forEach(table => tableMap[table.name] = table);\n    return {\n        stack: \"dbcore\",\n        transaction: db.transaction.bind(db),\n        table(name) {\n            const result = tableMap[name];\n            if (!result)\n                throw new Error(`Table '${name}' not found`);\n            return tableMap[name];\n        },\n        MIN_KEY: -Infinity,\n        MAX_KEY: getMaxKey(IdbKeyRange),\n        schema\n    };\n}\n\nfunction createMiddlewareStack(stackImpl, middlewares) {\n    return middlewares.reduce((down, { create }) => ({ ...down, ...create(down) }), stackImpl);\n}\nfunction createMiddlewareStacks(middlewares, idbdb, { IDBKeyRange, indexedDB }, tmpTrans) {\n    const dbcore = createMiddlewareStack(createDBCore(idbdb, IDBKeyRange, tmpTrans), middlewares.dbcore);\n    return {\n        dbcore\n    };\n}\nfunction generateMiddlewareStacks({ _novip: db }, tmpTrans) {\n    const idbdb = tmpTrans.db;\n    const stacks = createMiddlewareStacks(db._middlewares, idbdb, db._deps, tmpTrans);\n    db.core = stacks.dbcore;\n    db.tables.forEach(table => {\n        const tableName = table.name;\n        if (db.core.schema.tables.some(tbl => tbl.name === tableName)) {\n            table.core = db.core.table(tableName);\n            if (db[tableName] instanceof db.Table) {\n                db[tableName].core = table.core;\n            }\n        }\n    });\n}\n\nfunction setApiOnPlace({ _novip: db }, objs, tableNames, dbschema) {\n    tableNames.forEach(tableName => {\n        const schema = dbschema[tableName];\n        objs.forEach(obj => {\n            const propDesc = getPropertyDescriptor(obj, tableName);\n            if (!propDesc || (\"value\" in propDesc && propDesc.value === undefined)) {\n                if (obj === db.Transaction.prototype || obj instanceof db.Transaction) {\n                    setProp(obj, tableName, {\n                        get() { return this.table(tableName); },\n                        set(value) {\n                            defineProperty(this, tableName, { value, writable: true, configurable: true, enumerable: true });\n                        }\n                    });\n                }\n                else {\n                    obj[tableName] = new db.Table(tableName, schema);\n                }\n            }\n        });\n    });\n}\nfunction removeTablesApi({ _novip: db }, objs) {\n    objs.forEach(obj => {\n        for (let key in obj) {\n            if (obj[key] instanceof db.Table)\n                delete obj[key];\n        }\n    });\n}\nfunction lowerVersionFirst(a, b) {\n    return a._cfg.version - b._cfg.version;\n}\nfunction runUpgraders(db, oldVersion, idbUpgradeTrans, reject) {\n    const globalSchema = db._dbSchema;\n    const trans = db._createTransaction('readwrite', db._storeNames, globalSchema);\n    trans.create(idbUpgradeTrans);\n    trans._completion.catch(reject);\n    const rejectTransaction = trans._reject.bind(trans);\n    const transless = PSD.transless || PSD;\n    newScope(() => {\n        PSD.trans = trans;\n        PSD.transless = transless;\n        if (oldVersion === 0) {\n            keys(globalSchema).forEach(tableName => {\n                createTable(idbUpgradeTrans, tableName, globalSchema[tableName].primKey, globalSchema[tableName].indexes);\n            });\n            generateMiddlewareStacks(db, idbUpgradeTrans);\n            DexiePromise.follow(() => db.on.populate.fire(trans)).catch(rejectTransaction);\n        }\n        else\n            updateTablesAndIndexes(db, oldVersion, trans, idbUpgradeTrans).catch(rejectTransaction);\n    });\n}\nfunction updateTablesAndIndexes({ _novip: db }, oldVersion, trans, idbUpgradeTrans) {\n    const queue = [];\n    const versions = db._versions;\n    let globalSchema = db._dbSchema = buildGlobalSchema(db, db.idbdb, idbUpgradeTrans);\n    let anyContentUpgraderHasRun = false;\n    const versToRun = versions.filter(v => v._cfg.version >= oldVersion);\n    versToRun.forEach(version => {\n        queue.push(() => {\n            const oldSchema = globalSchema;\n            const newSchema = version._cfg.dbschema;\n            adjustToExistingIndexNames(db, oldSchema, idbUpgradeTrans);\n            adjustToExistingIndexNames(db, newSchema, idbUpgradeTrans);\n            globalSchema = db._dbSchema = newSchema;\n            const diff = getSchemaDiff(oldSchema, newSchema);\n            diff.add.forEach(tuple => {\n                createTable(idbUpgradeTrans, tuple[0], tuple[1].primKey, tuple[1].indexes);\n            });\n            diff.change.forEach(change => {\n                if (change.recreate) {\n                    throw new exceptions.Upgrade(\"Not yet support for changing primary key\");\n                }\n                else {\n                    const store = idbUpgradeTrans.objectStore(change.name);\n                    change.add.forEach(idx => addIndex(store, idx));\n                    change.change.forEach(idx => {\n                        store.deleteIndex(idx.name);\n                        addIndex(store, idx);\n                    });\n                    change.del.forEach(idxName => store.deleteIndex(idxName));\n                }\n            });\n            const contentUpgrade = version._cfg.contentUpgrade;\n            if (contentUpgrade && version._cfg.version > oldVersion) {\n                generateMiddlewareStacks(db, idbUpgradeTrans);\n                trans._memoizedTables = {};\n                anyContentUpgraderHasRun = true;\n                let upgradeSchema = shallowClone(newSchema);\n                diff.del.forEach(table => {\n                    upgradeSchema[table] = oldSchema[table];\n                });\n                removeTablesApi(db, [db.Transaction.prototype]);\n                setApiOnPlace(db, [db.Transaction.prototype], keys(upgradeSchema), upgradeSchema);\n                trans.schema = upgradeSchema;\n                const contentUpgradeIsAsync = isAsyncFunction(contentUpgrade);\n                if (contentUpgradeIsAsync) {\n                    incrementExpectedAwaits();\n                }\n                let returnValue;\n                const promiseFollowed = DexiePromise.follow(() => {\n                    returnValue = contentUpgrade(trans);\n                    if (returnValue) {\n                        if (contentUpgradeIsAsync) {\n                            var decrementor = decrementExpectedAwaits.bind(null, null);\n                            returnValue.then(decrementor, decrementor);\n                        }\n                    }\n                });\n                return (returnValue && typeof returnValue.then === 'function' ?\n                    DexiePromise.resolve(returnValue) : promiseFollowed.then(() => returnValue));\n            }\n        });\n        queue.push(idbtrans => {\n            if (!anyContentUpgraderHasRun || !hasIEDeleteObjectStoreBug) {\n                const newSchema = version._cfg.dbschema;\n                deleteRemovedTables(newSchema, idbtrans);\n            }\n            removeTablesApi(db, [db.Transaction.prototype]);\n            setApiOnPlace(db, [db.Transaction.prototype], db._storeNames, db._dbSchema);\n            trans.schema = db._dbSchema;\n        });\n    });\n    function runQueue() {\n        return queue.length ? DexiePromise.resolve(queue.shift()(trans.idbtrans)).then(runQueue) :\n            DexiePromise.resolve();\n    }\n    return runQueue().then(() => {\n        createMissingTables(globalSchema, idbUpgradeTrans);\n    });\n}\nfunction getSchemaDiff(oldSchema, newSchema) {\n    const diff = {\n        del: [],\n        add: [],\n        change: []\n    };\n    let table;\n    for (table in oldSchema) {\n        if (!newSchema[table])\n            diff.del.push(table);\n    }\n    for (table in newSchema) {\n        const oldDef = oldSchema[table], newDef = newSchema[table];\n        if (!oldDef) {\n            diff.add.push([table, newDef]);\n        }\n        else {\n            const change = {\n                name: table,\n                def: newDef,\n                recreate: false,\n                del: [],\n                add: [],\n                change: []\n            };\n            if ((\n            '' + (oldDef.primKey.keyPath || '')) !== ('' + (newDef.primKey.keyPath || '')) ||\n                (oldDef.primKey.auto !== newDef.primKey.auto && !isIEOrEdge))\n             {\n                change.recreate = true;\n                diff.change.push(change);\n            }\n            else {\n                const oldIndexes = oldDef.idxByName;\n                const newIndexes = newDef.idxByName;\n                let idxName;\n                for (idxName in oldIndexes) {\n                    if (!newIndexes[idxName])\n                        change.del.push(idxName);\n                }\n                for (idxName in newIndexes) {\n                    const oldIdx = oldIndexes[idxName], newIdx = newIndexes[idxName];\n                    if (!oldIdx)\n                        change.add.push(newIdx);\n                    else if (oldIdx.src !== newIdx.src)\n                        change.change.push(newIdx);\n                }\n                if (change.del.length > 0 || change.add.length > 0 || change.change.length > 0) {\n                    diff.change.push(change);\n                }\n            }\n        }\n    }\n    return diff;\n}\nfunction createTable(idbtrans, tableName, primKey, indexes) {\n    const store = idbtrans.db.createObjectStore(tableName, primKey.keyPath ?\n        { keyPath: primKey.keyPath, autoIncrement: primKey.auto } :\n        { autoIncrement: primKey.auto });\n    indexes.forEach(idx => addIndex(store, idx));\n    return store;\n}\nfunction createMissingTables(newSchema, idbtrans) {\n    keys(newSchema).forEach(tableName => {\n        if (!idbtrans.db.objectStoreNames.contains(tableName)) {\n            createTable(idbtrans, tableName, newSchema[tableName].primKey, newSchema[tableName].indexes);\n        }\n    });\n}\nfunction deleteRemovedTables(newSchema, idbtrans) {\n    [].slice.call(idbtrans.db.objectStoreNames).forEach(storeName => newSchema[storeName] == null && idbtrans.db.deleteObjectStore(storeName));\n}\nfunction addIndex(store, idx) {\n    store.createIndex(idx.name, idx.keyPath, { unique: idx.unique, multiEntry: idx.multi });\n}\nfunction buildGlobalSchema(db, idbdb, tmpTrans) {\n    const globalSchema = {};\n    const dbStoreNames = slice(idbdb.objectStoreNames, 0);\n    dbStoreNames.forEach(storeName => {\n        const store = tmpTrans.objectStore(storeName);\n        let keyPath = store.keyPath;\n        const primKey = createIndexSpec(nameFromKeyPath(keyPath), keyPath || \"\", false, false, !!store.autoIncrement, keyPath && typeof keyPath !== \"string\", true);\n        const indexes = [];\n        for (let j = 0; j < store.indexNames.length; ++j) {\n            const idbindex = store.index(store.indexNames[j]);\n            keyPath = idbindex.keyPath;\n            var index = createIndexSpec(idbindex.name, keyPath, !!idbindex.unique, !!idbindex.multiEntry, false, keyPath && typeof keyPath !== \"string\", false);\n            indexes.push(index);\n        }\n        globalSchema[storeName] = createTableSchema(storeName, primKey, indexes);\n    });\n    return globalSchema;\n}\nfunction readGlobalSchema({ _novip: db }, idbdb, tmpTrans) {\n    db.verno = idbdb.version / 10;\n    const globalSchema = db._dbSchema = buildGlobalSchema(db, idbdb, tmpTrans);\n    db._storeNames = slice(idbdb.objectStoreNames, 0);\n    setApiOnPlace(db, [db._allTables], keys(globalSchema), globalSchema);\n}\nfunction verifyInstalledSchema(db, tmpTrans) {\n    const installedSchema = buildGlobalSchema(db, db.idbdb, tmpTrans);\n    const diff = getSchemaDiff(installedSchema, db._dbSchema);\n    return !(diff.add.length || diff.change.some(ch => ch.add.length || ch.change.length));\n}\nfunction adjustToExistingIndexNames({ _novip: db }, schema, idbtrans) {\n    const storeNames = idbtrans.db.objectStoreNames;\n    for (let i = 0; i < storeNames.length; ++i) {\n        const storeName = storeNames[i];\n        const store = idbtrans.objectStore(storeName);\n        db._hasGetAll = 'getAll' in store;\n        for (let j = 0; j < store.indexNames.length; ++j) {\n            const indexName = store.indexNames[j];\n            const keyPath = store.index(indexName).keyPath;\n            const dexieName = typeof keyPath === 'string' ? keyPath : \"[\" + slice(keyPath).join('+') + \"]\";\n            if (schema[storeName]) {\n                const indexSpec = schema[storeName].idxByName[dexieName];\n                if (indexSpec) {\n                    indexSpec.name = indexName;\n                    delete schema[storeName].idxByName[dexieName];\n                    schema[storeName].idxByName[indexName] = indexSpec;\n                }\n            }\n        }\n    }\n    if (typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) &&\n        !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) &&\n        _global.WorkerGlobalScope && _global instanceof _global.WorkerGlobalScope &&\n        [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604) {\n        db._hasGetAll = false;\n    }\n}\nfunction parseIndexSyntax(primKeyAndIndexes) {\n    return primKeyAndIndexes.split(',').map((index, indexNum) => {\n        index = index.trim();\n        const name = index.replace(/([&*]|\\+\\+)/g, \"\");\n        const keyPath = /^\\[/.test(name) ? name.match(/^\\[(.*)\\]$/)[1].split('+') : name;\n        return createIndexSpec(name, keyPath || null, /\\&/.test(index), /\\*/.test(index), /\\+\\+/.test(index), isArray(keyPath), indexNum === 0);\n    });\n}\n\nclass Version {\n    _parseStoresSpec(stores, outSchema) {\n        keys(stores).forEach(tableName => {\n            if (stores[tableName] !== null) {\n                var indexes = parseIndexSyntax(stores[tableName]);\n                var primKey = indexes.shift();\n                if (primKey.multi)\n                    throw new exceptions.Schema(\"Primary key cannot be multi-valued\");\n                indexes.forEach(idx => {\n                    if (idx.auto)\n                        throw new exceptions.Schema(\"Only primary key can be marked as autoIncrement (++)\");\n                    if (!idx.keyPath)\n                        throw new exceptions.Schema(\"Index must have a name and cannot be an empty string\");\n                });\n                outSchema[tableName] = createTableSchema(tableName, primKey, indexes);\n            }\n        });\n    }\n    stores(stores) {\n        const db = this.db;\n        this._cfg.storesSource = this._cfg.storesSource ?\n            extend(this._cfg.storesSource, stores) :\n            stores;\n        const versions = db._versions;\n        const storesSpec = {};\n        let dbschema = {};\n        versions.forEach(version => {\n            extend(storesSpec, version._cfg.storesSource);\n            dbschema = (version._cfg.dbschema = {});\n            version._parseStoresSpec(storesSpec, dbschema);\n        });\n        db._dbSchema = dbschema;\n        removeTablesApi(db, [db._allTables, db, db.Transaction.prototype]);\n        setApiOnPlace(db, [db._allTables, db, db.Transaction.prototype, this._cfg.tables], keys(dbschema), dbschema);\n        db._storeNames = keys(dbschema);\n        return this;\n    }\n    upgrade(upgradeFunction) {\n        this._cfg.contentUpgrade = promisableChain(this._cfg.contentUpgrade || nop, upgradeFunction);\n        return this;\n    }\n}\n\nfunction createVersionConstructor(db) {\n    return makeClassConstructor(Version.prototype, function Version(versionNumber) {\n        this.db = db;\n        this._cfg = {\n            version: versionNumber,\n            storesSource: null,\n            dbschema: {},\n            tables: {},\n            contentUpgrade: null\n        };\n    });\n}\n\nfunction getDbNamesTable(indexedDB, IDBKeyRange) {\n    let dbNamesDB = indexedDB[\"_dbNamesDB\"];\n    if (!dbNamesDB) {\n        dbNamesDB = indexedDB[\"_dbNamesDB\"] = new Dexie$1(DBNAMES_DB, {\n            addons: [],\n            indexedDB,\n            IDBKeyRange,\n        });\n        dbNamesDB.version(1).stores({ dbnames: \"name\" });\n    }\n    return dbNamesDB.table(\"dbnames\");\n}\nfunction hasDatabasesNative(indexedDB) {\n    return indexedDB && typeof indexedDB.databases === \"function\";\n}\nfunction getDatabaseNames({ indexedDB, IDBKeyRange, }) {\n    return hasDatabasesNative(indexedDB)\n        ? Promise.resolve(indexedDB.databases()).then((infos) => infos\n            .map((info) => info.name)\n            .filter((name) => name !== DBNAMES_DB))\n        : getDbNamesTable(indexedDB, IDBKeyRange).toCollection().primaryKeys();\n}\nfunction _onDatabaseCreated({ indexedDB, IDBKeyRange }, name) {\n    !hasDatabasesNative(indexedDB) &&\n        name !== DBNAMES_DB &&\n        getDbNamesTable(indexedDB, IDBKeyRange).put({ name }).catch(nop);\n}\nfunction _onDatabaseDeleted({ indexedDB, IDBKeyRange }, name) {\n    !hasDatabasesNative(indexedDB) &&\n        name !== DBNAMES_DB &&\n        getDbNamesTable(indexedDB, IDBKeyRange).delete(name).catch(nop);\n}\n\nfunction vip(fn) {\n    return newScope(function () {\n        PSD.letThrough = true;\n        return fn();\n    });\n}\n\nfunction idbReady() {\n    var isSafari = !navigator.userAgentData &&\n        /Safari\\//.test(navigator.userAgent) &&\n        !/Chrom(e|ium)\\//.test(navigator.userAgent);\n    if (!isSafari || !indexedDB.databases)\n        return Promise.resolve();\n    var intervalId;\n    return new Promise(function (resolve) {\n        var tryIdb = function () { return indexedDB.databases().finally(resolve); };\n        intervalId = setInterval(tryIdb, 100);\n        tryIdb();\n    }).finally(function () { return clearInterval(intervalId); });\n}\n\nfunction dexieOpen(db) {\n    const state = db._state;\n    const { indexedDB } = db._deps;\n    if (state.isBeingOpened || db.idbdb)\n        return state.dbReadyPromise.then(() => state.dbOpenError ?\n            rejection(state.dbOpenError) :\n            db);\n    debug && (state.openCanceller._stackHolder = getErrorWithStack());\n    state.isBeingOpened = true;\n    state.dbOpenError = null;\n    state.openComplete = false;\n    const openCanceller = state.openCanceller;\n    function throwIfCancelled() {\n        if (state.openCanceller !== openCanceller)\n            throw new exceptions.DatabaseClosed('db.open() was cancelled');\n    }\n    let resolveDbReady = state.dbReadyResolve,\n    upgradeTransaction = null, wasCreated = false;\n    return DexiePromise.race([openCanceller, (typeof navigator === 'undefined' ? DexiePromise.resolve() : idbReady()).then(() => new DexiePromise((resolve, reject) => {\n            throwIfCancelled();\n            if (!indexedDB)\n                throw new exceptions.MissingAPI();\n            const dbName = db.name;\n            const req = state.autoSchema ?\n                indexedDB.open(dbName) :\n                indexedDB.open(dbName, Math.round(db.verno * 10));\n            if (!req)\n                throw new exceptions.MissingAPI();\n            req.onerror = eventRejectHandler(reject);\n            req.onblocked = wrap(db._fireOnBlocked);\n            req.onupgradeneeded = wrap(e => {\n                upgradeTransaction = req.transaction;\n                if (state.autoSchema && !db._options.allowEmptyDB) {\n                    req.onerror = preventDefault;\n                    upgradeTransaction.abort();\n                    req.result.close();\n                    const delreq = indexedDB.deleteDatabase(dbName);\n                    delreq.onsuccess = delreq.onerror = wrap(() => {\n                        reject(new exceptions.NoSuchDatabase(`Database ${dbName} doesnt exist`));\n                    });\n                }\n                else {\n                    upgradeTransaction.onerror = eventRejectHandler(reject);\n                    var oldVer = e.oldVersion > Math.pow(2, 62) ? 0 : e.oldVersion;\n                    wasCreated = oldVer < 1;\n                    db._novip.idbdb = req.result;\n                    runUpgraders(db, oldVer / 10, upgradeTransaction, reject);\n                }\n            }, reject);\n            req.onsuccess = wrap(() => {\n                upgradeTransaction = null;\n                const idbdb = db._novip.idbdb = req.result;\n                const objectStoreNames = slice(idbdb.objectStoreNames);\n                if (objectStoreNames.length > 0)\n                    try {\n                        const tmpTrans = idbdb.transaction(safariMultiStoreFix(objectStoreNames), 'readonly');\n                        if (state.autoSchema)\n                            readGlobalSchema(db, idbdb, tmpTrans);\n                        else {\n                            adjustToExistingIndexNames(db, db._dbSchema, tmpTrans);\n                            if (!verifyInstalledSchema(db, tmpTrans)) {\n                                console.warn(`Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Some queries may fail.`);\n                            }\n                        }\n                        generateMiddlewareStacks(db, tmpTrans);\n                    }\n                    catch (e) {\n                    }\n                connections.push(db);\n                idbdb.onversionchange = wrap(ev => {\n                    state.vcFired = true;\n                    db.on(\"versionchange\").fire(ev);\n                });\n                idbdb.onclose = wrap(ev => {\n                    db.on(\"close\").fire(ev);\n                });\n                if (wasCreated)\n                    _onDatabaseCreated(db._deps, dbName);\n                resolve();\n            }, reject);\n        }))]).then(() => {\n        throwIfCancelled();\n        state.onReadyBeingFired = [];\n        return DexiePromise.resolve(vip(() => db.on.ready.fire(db.vip))).then(function fireRemainders() {\n            if (state.onReadyBeingFired.length > 0) {\n                let remainders = state.onReadyBeingFired.reduce(promisableChain, nop);\n                state.onReadyBeingFired = [];\n                return DexiePromise.resolve(vip(() => remainders(db.vip))).then(fireRemainders);\n            }\n        });\n    }).finally(() => {\n        state.onReadyBeingFired = null;\n        state.isBeingOpened = false;\n    }).then(() => {\n        return db;\n    }).catch(err => {\n        state.dbOpenError = err;\n        try {\n            upgradeTransaction && upgradeTransaction.abort();\n        }\n        catch (_a) { }\n        if (openCanceller === state.openCanceller) {\n            db._close();\n        }\n        return rejection(err);\n    }).finally(() => {\n        state.openComplete = true;\n        resolveDbReady();\n    });\n}\n\nfunction awaitIterator(iterator) {\n    var callNext = result => iterator.next(result), doThrow = error => iterator.throw(error), onSuccess = step(callNext), onError = step(doThrow);\n    function step(getNext) {\n        return (val) => {\n            var next = getNext(val), value = next.value;\n            return next.done ? value :\n                (!value || typeof value.then !== 'function' ?\n                    isArray(value) ? Promise.all(value).then(onSuccess, onError) : onSuccess(value) :\n                    value.then(onSuccess, onError));\n        };\n    }\n    return step(callNext)();\n}\n\nfunction extractTransactionArgs(mode, _tableArgs_, scopeFunc) {\n    var i = arguments.length;\n    if (i < 2)\n        throw new exceptions.InvalidArgument(\"Too few arguments\");\n    var args = new Array(i - 1);\n    while (--i)\n        args[i - 1] = arguments[i];\n    scopeFunc = args.pop();\n    var tables = flatten(args);\n    return [mode, tables, scopeFunc];\n}\nfunction enterTransactionScope(db, mode, storeNames, parentTransaction, scopeFunc) {\n    return DexiePromise.resolve().then(() => {\n        const transless = PSD.transless || PSD;\n        const trans = db._createTransaction(mode, storeNames, db._dbSchema, parentTransaction);\n        const zoneProps = {\n            trans: trans,\n            transless: transless\n        };\n        if (parentTransaction) {\n            trans.idbtrans = parentTransaction.idbtrans;\n        }\n        else {\n            try {\n                trans.create();\n                db._state.PR1398_maxLoop = 3;\n            }\n            catch (ex) {\n                if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {\n                    console.warn('Dexie: Need to reopen db');\n                    db._close();\n                    return db.open().then(() => enterTransactionScope(db, mode, storeNames, null, scopeFunc));\n                }\n                return rejection(ex);\n            }\n        }\n        const scopeFuncIsAsync = isAsyncFunction(scopeFunc);\n        if (scopeFuncIsAsync) {\n            incrementExpectedAwaits();\n        }\n        let returnValue;\n        const promiseFollowed = DexiePromise.follow(() => {\n            returnValue = scopeFunc.call(trans, trans);\n            if (returnValue) {\n                if (scopeFuncIsAsync) {\n                    var decrementor = decrementExpectedAwaits.bind(null, null);\n                    returnValue.then(decrementor, decrementor);\n                }\n                else if (typeof returnValue.next === 'function' && typeof returnValue.throw === 'function') {\n                    returnValue = awaitIterator(returnValue);\n                }\n            }\n        }, zoneProps);\n        return (returnValue && typeof returnValue.then === 'function' ?\n            DexiePromise.resolve(returnValue).then(x => trans.active ?\n                x\n                : rejection(new exceptions.PrematureCommit(\"Transaction committed too early. See http://bit.ly/2kdckMn\")))\n            : promiseFollowed.then(() => returnValue)).then(x => {\n            if (parentTransaction)\n                trans._resolve();\n            return trans._completion.then(() => x);\n        }).catch(e => {\n            trans._reject(e);\n            return rejection(e);\n        });\n    });\n}\n\nfunction pad(a, value, count) {\n    const result = isArray(a) ? a.slice() : [a];\n    for (let i = 0; i < count; ++i)\n        result.push(value);\n    return result;\n}\nfunction createVirtualIndexMiddleware(down) {\n    return {\n        ...down,\n        table(tableName) {\n            const table = down.table(tableName);\n            const { schema } = table;\n            const indexLookup = {};\n            const allVirtualIndexes = [];\n            function addVirtualIndexes(keyPath, keyTail, lowLevelIndex) {\n                const keyPathAlias = getKeyPathAlias(keyPath);\n                const indexList = (indexLookup[keyPathAlias] = indexLookup[keyPathAlias] || []);\n                const keyLength = keyPath == null ? 0 : typeof keyPath === 'string' ? 1 : keyPath.length;\n                const isVirtual = keyTail > 0;\n                const virtualIndex = {\n                    ...lowLevelIndex,\n                    isVirtual,\n                    keyTail,\n                    keyLength,\n                    extractKey: getKeyExtractor(keyPath),\n                    unique: !isVirtual && lowLevelIndex.unique\n                };\n                indexList.push(virtualIndex);\n                if (!virtualIndex.isPrimaryKey) {\n                    allVirtualIndexes.push(virtualIndex);\n                }\n                if (keyLength > 1) {\n                    const virtualKeyPath = keyLength === 2 ?\n                        keyPath[0] :\n                        keyPath.slice(0, keyLength - 1);\n                    addVirtualIndexes(virtualKeyPath, keyTail + 1, lowLevelIndex);\n                }\n                indexList.sort((a, b) => a.keyTail - b.keyTail);\n                return virtualIndex;\n            }\n            const primaryKey = addVirtualIndexes(schema.primaryKey.keyPath, 0, schema.primaryKey);\n            indexLookup[\":id\"] = [primaryKey];\n            for (const index of schema.indexes) {\n                addVirtualIndexes(index.keyPath, 0, index);\n            }\n            function findBestIndex(keyPath) {\n                const result = indexLookup[getKeyPathAlias(keyPath)];\n                return result && result[0];\n            }\n            function translateRange(range, keyTail) {\n                return {\n                    type: range.type === 1  ?\n                        2  :\n                        range.type,\n                    lower: pad(range.lower, range.lowerOpen ? down.MAX_KEY : down.MIN_KEY, keyTail),\n                    lowerOpen: true,\n                    upper: pad(range.upper, range.upperOpen ? down.MIN_KEY : down.MAX_KEY, keyTail),\n                    upperOpen: true\n                };\n            }\n            function translateRequest(req) {\n                const index = req.query.index;\n                return index.isVirtual ? {\n                    ...req,\n                    query: {\n                        index,\n                        range: translateRange(req.query.range, index.keyTail)\n                    }\n                } : req;\n            }\n            const result = {\n                ...table,\n                schema: {\n                    ...schema,\n                    primaryKey,\n                    indexes: allVirtualIndexes,\n                    getIndexByKeyPath: findBestIndex\n                },\n                count(req) {\n                    return table.count(translateRequest(req));\n                },\n                query(req) {\n                    return table.query(translateRequest(req));\n                },\n                openCursor(req) {\n                    const { keyTail, isVirtual, keyLength } = req.query.index;\n                    if (!isVirtual)\n                        return table.openCursor(req);\n                    function createVirtualCursor(cursor) {\n                        function _continue(key) {\n                            key != null ?\n                                cursor.continue(pad(key, req.reverse ? down.MAX_KEY : down.MIN_KEY, keyTail)) :\n                                req.unique ?\n                                    cursor.continue(cursor.key.slice(0, keyLength)\n                                        .concat(req.reverse\n                                        ? down.MIN_KEY\n                                        : down.MAX_KEY, keyTail)) :\n                                    cursor.continue();\n                        }\n                        const virtualCursor = Object.create(cursor, {\n                            continue: { value: _continue },\n                            continuePrimaryKey: {\n                                value(key, primaryKey) {\n                                    cursor.continuePrimaryKey(pad(key, down.MAX_KEY, keyTail), primaryKey);\n                                }\n                            },\n                            primaryKey: {\n                                get() {\n                                    return cursor.primaryKey;\n                                }\n                            },\n                            key: {\n                                get() {\n                                    const key = cursor.key;\n                                    return keyLength === 1 ?\n                                        key[0] :\n                                        key.slice(0, keyLength);\n                                }\n                            },\n                            value: {\n                                get() {\n                                    return cursor.value;\n                                }\n                            }\n                        });\n                        return virtualCursor;\n                    }\n                    return table.openCursor(translateRequest(req))\n                        .then(cursor => cursor && createVirtualCursor(cursor));\n                }\n            };\n            return result;\n        }\n    };\n}\nconst virtualIndexMiddleware = {\n    stack: \"dbcore\",\n    name: \"VirtualIndexMiddleware\",\n    level: 1,\n    create: createVirtualIndexMiddleware\n};\n\nfunction getObjectDiff(a, b, rv, prfx) {\n    rv = rv || {};\n    prfx = prfx || '';\n    keys(a).forEach((prop) => {\n        if (!hasOwn(b, prop)) {\n            rv[prfx + prop] = undefined;\n        }\n        else {\n            var ap = a[prop], bp = b[prop];\n            if (typeof ap === 'object' && typeof bp === 'object' && ap && bp) {\n                const apTypeName = toStringTag(ap);\n                const bpTypeName = toStringTag(bp);\n                if (apTypeName !== bpTypeName) {\n                    rv[prfx + prop] = b[prop];\n                }\n                else if (apTypeName === 'Object') {\n                    getObjectDiff(ap, bp, rv, prfx + prop + '.');\n                }\n                else if (ap !== bp) {\n                    rv[prfx + prop] = b[prop];\n                }\n            }\n            else if (ap !== bp)\n                rv[prfx + prop] = b[prop];\n        }\n    });\n    keys(b).forEach((prop) => {\n        if (!hasOwn(a, prop)) {\n            rv[prfx + prop] = b[prop];\n        }\n    });\n    return rv;\n}\n\nfunction getEffectiveKeys(primaryKey, req) {\n    if (req.type === 'delete')\n        return req.keys;\n    return req.keys || req.values.map(primaryKey.extractKey);\n}\n\nconst hooksMiddleware = {\n    stack: \"dbcore\",\n    name: \"HooksMiddleware\",\n    level: 2,\n    create: (downCore) => ({\n        ...downCore,\n        table(tableName) {\n            const downTable = downCore.table(tableName);\n            const { primaryKey } = downTable.schema;\n            const tableMiddleware = {\n                ...downTable,\n                mutate(req) {\n                    const dxTrans = PSD.trans;\n                    const { deleting, creating, updating } = dxTrans.table(tableName).hook;\n                    switch (req.type) {\n                        case 'add':\n                            if (creating.fire === nop)\n                                break;\n                            return dxTrans._promise('readwrite', () => addPutOrDelete(req), true);\n                        case 'put':\n                            if (creating.fire === nop && updating.fire === nop)\n                                break;\n                            return dxTrans._promise('readwrite', () => addPutOrDelete(req), true);\n                        case 'delete':\n                            if (deleting.fire === nop)\n                                break;\n                            return dxTrans._promise('readwrite', () => addPutOrDelete(req), true);\n                        case 'deleteRange':\n                            if (deleting.fire === nop)\n                                break;\n                            return dxTrans._promise('readwrite', () => deleteRange(req), true);\n                    }\n                    return downTable.mutate(req);\n                    function addPutOrDelete(req) {\n                        const dxTrans = PSD.trans;\n                        const keys = req.keys || getEffectiveKeys(primaryKey, req);\n                        if (!keys)\n                            throw new Error(\"Keys missing\");\n                        req = req.type === 'add' || req.type === 'put' ?\n                            { ...req, keys } :\n                            { ...req };\n                        if (req.type !== 'delete')\n                            req.values = [...req.values];\n                        if (req.keys)\n                            req.keys = [...req.keys];\n                        return getExistingValues(downTable, req, keys).then(existingValues => {\n                            const contexts = keys.map((key, i) => {\n                                const existingValue = existingValues[i];\n                                const ctx = { onerror: null, onsuccess: null };\n                                if (req.type === 'delete') {\n                                    deleting.fire.call(ctx, key, existingValue, dxTrans);\n                                }\n                                else if (req.type === 'add' || existingValue === undefined) {\n                                    const generatedPrimaryKey = creating.fire.call(ctx, key, req.values[i], dxTrans);\n                                    if (key == null && generatedPrimaryKey != null) {\n                                        key = generatedPrimaryKey;\n                                        req.keys[i] = key;\n                                        if (!primaryKey.outbound) {\n                                            setByKeyPath(req.values[i], primaryKey.keyPath, key);\n                                        }\n                                    }\n                                }\n                                else {\n                                    const objectDiff = getObjectDiff(existingValue, req.values[i]);\n                                    const additionalChanges = updating.fire.call(ctx, objectDiff, key, existingValue, dxTrans);\n                                    if (additionalChanges) {\n                                        const requestedValue = req.values[i];\n                                        Object.keys(additionalChanges).forEach(keyPath => {\n                                            if (hasOwn(requestedValue, keyPath)) {\n                                                requestedValue[keyPath] = additionalChanges[keyPath];\n                                            }\n                                            else {\n                                                setByKeyPath(requestedValue, keyPath, additionalChanges[keyPath]);\n                                            }\n                                        });\n                                    }\n                                }\n                                return ctx;\n                            });\n                            return downTable.mutate(req).then(({ failures, results, numFailures, lastResult }) => {\n                                for (let i = 0; i < keys.length; ++i) {\n                                    const primKey = results ? results[i] : keys[i];\n                                    const ctx = contexts[i];\n                                    if (primKey == null) {\n                                        ctx.onerror && ctx.onerror(failures[i]);\n                                    }\n                                    else {\n                                        ctx.onsuccess && ctx.onsuccess(req.type === 'put' && existingValues[i] ?\n                                            req.values[i] :\n                                            primKey\n                                        );\n                                    }\n                                }\n                                return { failures, results, numFailures, lastResult };\n                            }).catch(error => {\n                                contexts.forEach(ctx => ctx.onerror && ctx.onerror(error));\n                                return Promise.reject(error);\n                            });\n                        });\n                    }\n                    function deleteRange(req) {\n                        return deleteNextChunk(req.trans, req.range, 10000);\n                    }\n                    function deleteNextChunk(trans, range, limit) {\n                        return downTable.query({ trans, values: false, query: { index: primaryKey, range }, limit })\n                            .then(({ result }) => {\n                            return addPutOrDelete({ type: 'delete', keys: result, trans }).then(res => {\n                                if (res.numFailures > 0)\n                                    return Promise.reject(res.failures[0]);\n                                if (result.length < limit) {\n                                    return { failures: [], numFailures: 0, lastResult: undefined };\n                                }\n                                else {\n                                    return deleteNextChunk(trans, { ...range, lower: result[result.length - 1], lowerOpen: true }, limit);\n                                }\n                            });\n                        });\n                    }\n                }\n            };\n            return tableMiddleware;\n        },\n    })\n};\nfunction getExistingValues(table, req, effectiveKeys) {\n    return req.type === \"add\"\n        ? Promise.resolve([])\n        : table.getMany({ trans: req.trans, keys: effectiveKeys, cache: \"immutable\" });\n}\n\nfunction getFromTransactionCache(keys, cache, clone) {\n    try {\n        if (!cache)\n            return null;\n        if (cache.keys.length < keys.length)\n            return null;\n        const result = [];\n        for (let i = 0, j = 0; i < cache.keys.length && j < keys.length; ++i) {\n            if (cmp(cache.keys[i], keys[j]) !== 0)\n                continue;\n            result.push(clone ? deepClone(cache.values[i]) : cache.values[i]);\n            ++j;\n        }\n        return result.length === keys.length ? result : null;\n    }\n    catch (_a) {\n        return null;\n    }\n}\nconst cacheExistingValuesMiddleware = {\n    stack: \"dbcore\",\n    level: -1,\n    create: (core) => {\n        return {\n            table: (tableName) => {\n                const table = core.table(tableName);\n                return {\n                    ...table,\n                    getMany: (req) => {\n                        if (!req.cache) {\n                            return table.getMany(req);\n                        }\n                        const cachedResult = getFromTransactionCache(req.keys, req.trans[\"_cache\"], req.cache === \"clone\");\n                        if (cachedResult) {\n                            return DexiePromise.resolve(cachedResult);\n                        }\n                        return table.getMany(req).then((res) => {\n                            req.trans[\"_cache\"] = {\n                                keys: req.keys,\n                                values: req.cache === \"clone\" ? deepClone(res) : res,\n                            };\n                            return res;\n                        });\n                    },\n                    mutate: (req) => {\n                        if (req.type !== \"add\")\n                            req.trans[\"_cache\"] = null;\n                        return table.mutate(req);\n                    },\n                };\n            },\n        };\n    },\n};\n\nfunction isEmptyRange(node) {\n    return !(\"from\" in node);\n}\nconst RangeSet = function (fromOrTree, to) {\n    if (this) {\n        extend(this, arguments.length ? { d: 1, from: fromOrTree, to: arguments.length > 1 ? to : fromOrTree } : { d: 0 });\n    }\n    else {\n        const rv = new RangeSet();\n        if (fromOrTree && (\"d\" in fromOrTree)) {\n            extend(rv, fromOrTree);\n        }\n        return rv;\n    }\n};\nprops(RangeSet.prototype, {\n    add(rangeSet) {\n        mergeRanges(this, rangeSet);\n        return this;\n    },\n    addKey(key) {\n        addRange(this, key, key);\n        return this;\n    },\n    addKeys(keys) {\n        keys.forEach(key => addRange(this, key, key));\n        return this;\n    },\n    [iteratorSymbol]() {\n        return getRangeSetIterator(this);\n    }\n});\nfunction addRange(target, from, to) {\n    const diff = cmp(from, to);\n    if (isNaN(diff))\n        return;\n    if (diff > 0)\n        throw RangeError();\n    if (isEmptyRange(target))\n        return extend(target, { from, to, d: 1 });\n    const left = target.l;\n    const right = target.r;\n    if (cmp(to, target.from) < 0) {\n        left\n            ? addRange(left, from, to)\n            : (target.l = { from, to, d: 1, l: null, r: null });\n        return rebalance(target);\n    }\n    if (cmp(from, target.to) > 0) {\n        right\n            ? addRange(right, from, to)\n            : (target.r = { from, to, d: 1, l: null, r: null });\n        return rebalance(target);\n    }\n    if (cmp(from, target.from) < 0) {\n        target.from = from;\n        target.l = null;\n        target.d = right ? right.d + 1 : 1;\n    }\n    if (cmp(to, target.to) > 0) {\n        target.to = to;\n        target.r = null;\n        target.d = target.l ? target.l.d + 1 : 1;\n    }\n    const rightWasCutOff = !target.r;\n    if (left && !target.l) {\n        mergeRanges(target, left);\n    }\n    if (right && rightWasCutOff) {\n        mergeRanges(target, right);\n    }\n}\nfunction mergeRanges(target, newSet) {\n    function _addRangeSet(target, { from, to, l, r }) {\n        addRange(target, from, to);\n        if (l)\n            _addRangeSet(target, l);\n        if (r)\n            _addRangeSet(target, r);\n    }\n    if (!isEmptyRange(newSet))\n        _addRangeSet(target, newSet);\n}\nfunction rangesOverlap(rangeSet1, rangeSet2) {\n    const i1 = getRangeSetIterator(rangeSet2);\n    let nextResult1 = i1.next();\n    if (nextResult1.done)\n        return false;\n    let a = nextResult1.value;\n    const i2 = getRangeSetIterator(rangeSet1);\n    let nextResult2 = i2.next(a.from);\n    let b = nextResult2.value;\n    while (!nextResult1.done && !nextResult2.done) {\n        if (cmp(b.from, a.to) <= 0 && cmp(b.to, a.from) >= 0)\n            return true;\n        cmp(a.from, b.from) < 0\n            ? (a = (nextResult1 = i1.next(b.from)).value)\n            : (b = (nextResult2 = i2.next(a.from)).value);\n    }\n    return false;\n}\nfunction getRangeSetIterator(node) {\n    let state = isEmptyRange(node) ? null : { s: 0, n: node };\n    return {\n        next(key) {\n            const keyProvided = arguments.length > 0;\n            while (state) {\n                switch (state.s) {\n                    case 0:\n                        state.s = 1;\n                        if (keyProvided) {\n                            while (state.n.l && cmp(key, state.n.from) < 0)\n                                state = { up: state, n: state.n.l, s: 1 };\n                        }\n                        else {\n                            while (state.n.l)\n                                state = { up: state, n: state.n.l, s: 1 };\n                        }\n                    case 1:\n                        state.s = 2;\n                        if (!keyProvided || cmp(key, state.n.to) <= 0)\n                            return { value: state.n, done: false };\n                    case 2:\n                        if (state.n.r) {\n                            state.s = 3;\n                            state = { up: state, n: state.n.r, s: 0 };\n                            continue;\n                        }\n                    case 3:\n                        state = state.up;\n                }\n            }\n            return { done: true };\n        },\n    };\n}\nfunction rebalance(target) {\n    var _a, _b;\n    const diff = (((_a = target.r) === null || _a === void 0 ? void 0 : _a.d) || 0) - (((_b = target.l) === null || _b === void 0 ? void 0 : _b.d) || 0);\n    const r = diff > 1 ? \"r\" : diff < -1 ? \"l\" : \"\";\n    if (r) {\n        const l = r === \"r\" ? \"l\" : \"r\";\n        const rootClone = { ...target };\n        const oldRootRight = target[r];\n        target.from = oldRootRight.from;\n        target.to = oldRootRight.to;\n        target[r] = oldRootRight[r];\n        rootClone[r] = oldRootRight[l];\n        target[l] = rootClone;\n        rootClone.d = computeDepth(rootClone);\n    }\n    target.d = computeDepth(target);\n}\nfunction computeDepth({ r, l }) {\n    return (r ? (l ? Math.max(r.d, l.d) : r.d) : l ? l.d : 0) + 1;\n}\n\nconst observabilityMiddleware = {\n    stack: \"dbcore\",\n    level: 0,\n    create: (core) => {\n        const dbName = core.schema.name;\n        const FULL_RANGE = new RangeSet(core.MIN_KEY, core.MAX_KEY);\n        return {\n            ...core,\n            table: (tableName) => {\n                const table = core.table(tableName);\n                const { schema } = table;\n                const { primaryKey } = schema;\n                const { extractKey, outbound } = primaryKey;\n                const tableClone = {\n                    ...table,\n                    mutate: (req) => {\n                        const trans = req.trans;\n                        const mutatedParts = trans.mutatedParts || (trans.mutatedParts = {});\n                        const getRangeSet = (indexName) => {\n                            const part = `idb://${dbName}/${tableName}/${indexName}`;\n                            return (mutatedParts[part] ||\n                                (mutatedParts[part] = new RangeSet()));\n                        };\n                        const pkRangeSet = getRangeSet(\"\");\n                        const delsRangeSet = getRangeSet(\":dels\");\n                        const { type } = req;\n                        let [keys, newObjs] = req.type === \"deleteRange\"\n                            ? [req.range]\n                            : req.type === \"delete\"\n                                ? [req.keys]\n                                : req.values.length < 50\n                                    ? [[], req.values]\n                                    : [];\n                        const oldCache = req.trans[\"_cache\"];\n                        return table.mutate(req).then((res) => {\n                            if (isArray(keys)) {\n                                if (type !== \"delete\")\n                                    keys = res.results;\n                                pkRangeSet.addKeys(keys);\n                                const oldObjs = getFromTransactionCache(keys, oldCache);\n                                if (!oldObjs && type !== \"add\") {\n                                    delsRangeSet.addKeys(keys);\n                                }\n                                if (oldObjs || newObjs) {\n                                    trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs);\n                                }\n                            }\n                            else if (keys) {\n                                const range = { from: keys.lower, to: keys.upper };\n                                delsRangeSet.add(range);\n                                pkRangeSet.add(range);\n                            }\n                            else {\n                                pkRangeSet.add(FULL_RANGE);\n                                delsRangeSet.add(FULL_RANGE);\n                                schema.indexes.forEach(idx => getRangeSet(idx.name).add(FULL_RANGE));\n                            }\n                            return res;\n                        });\n                    },\n                };\n                const getRange = ({ query: { index, range }, }) => {\n                    var _a, _b;\n                    return [\n                        index,\n                        new RangeSet((_a = range.lower) !== null && _a !== void 0 ? _a : core.MIN_KEY, (_b = range.upper) !== null && _b !== void 0 ? _b : core.MAX_KEY),\n                    ];\n                };\n                const readSubscribers = {\n                    get: (req) => [primaryKey, new RangeSet(req.key)],\n                    getMany: (req) => [primaryKey, new RangeSet().addKeys(req.keys)],\n                    count: getRange,\n                    query: getRange,\n                    openCursor: getRange,\n                };\n                keys(readSubscribers).forEach(method => {\n                    tableClone[method] = function (req) {\n                        const { subscr } = PSD;\n                        if (subscr) {\n                            const getRangeSet = (indexName) => {\n                                const part = `idb://${dbName}/${tableName}/${indexName}`;\n                                return (subscr[part] ||\n                                    (subscr[part] = new RangeSet()));\n                            };\n                            const pkRangeSet = getRangeSet(\"\");\n                            const delsRangeSet = getRangeSet(\":dels\");\n                            const [queriedIndex, queriedRanges] = readSubscribers[method](req);\n                            getRangeSet(queriedIndex.name || \"\").add(queriedRanges);\n                            if (!queriedIndex.isPrimaryKey) {\n                                if (method === \"count\") {\n                                    delsRangeSet.add(FULL_RANGE);\n                                }\n                                else {\n                                    const keysPromise = method === \"query\" &&\n                                        outbound &&\n                                        req.values &&\n                                        table.query({\n                                            ...req,\n                                            values: false,\n                                        });\n                                    return table[method].apply(this, arguments).then((res) => {\n                                        if (method === \"query\") {\n                                            if (outbound && req.values) {\n                                                return keysPromise.then(({ result: resultingKeys }) => {\n                                                    pkRangeSet.addKeys(resultingKeys);\n                                                    return res;\n                                                });\n                                            }\n                                            const pKeys = req.values\n                                                ? res.result.map(extractKey)\n                                                : res.result;\n                                            if (req.values) {\n                                                pkRangeSet.addKeys(pKeys);\n                                            }\n                                            else {\n                                                delsRangeSet.addKeys(pKeys);\n                                            }\n                                        }\n                                        else if (method === \"openCursor\") {\n                                            const cursor = res;\n                                            const wantValues = req.values;\n                                            return (cursor &&\n                                                Object.create(cursor, {\n                                                    key: {\n                                                        get() {\n                                                            delsRangeSet.addKey(cursor.primaryKey);\n                                                            return cursor.key;\n                                                        },\n                                                    },\n                                                    primaryKey: {\n                                                        get() {\n                                                            const pkey = cursor.primaryKey;\n                                                            delsRangeSet.addKey(pkey);\n                                                            return pkey;\n                                                        },\n                                                    },\n                                                    value: {\n                                                        get() {\n                                                            wantValues && pkRangeSet.addKey(cursor.primaryKey);\n                                                            return cursor.value;\n                                                        },\n                                                    },\n                                                }));\n                                        }\n                                        return res;\n                                    });\n                                }\n                            }\n                        }\n                        return table[method].apply(this, arguments);\n                    };\n                });\n                return tableClone;\n            },\n        };\n    },\n};\nfunction trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs) {\n    function addAffectedIndex(ix) {\n        const rangeSet = getRangeSet(ix.name || \"\");\n        function extractKey(obj) {\n            return obj != null ? ix.extractKey(obj) : null;\n        }\n        const addKeyOrKeys = (key) => ix.multiEntry && isArray(key)\n            ? key.forEach(key => rangeSet.addKey(key))\n            : rangeSet.addKey(key);\n        (oldObjs || newObjs).forEach((_, i) => {\n            const oldKey = oldObjs && extractKey(oldObjs[i]);\n            const newKey = newObjs && extractKey(newObjs[i]);\n            if (cmp(oldKey, newKey) !== 0) {\n                if (oldKey != null)\n                    addKeyOrKeys(oldKey);\n                if (newKey != null)\n                    addKeyOrKeys(newKey);\n            }\n        });\n    }\n    schema.indexes.forEach(addAffectedIndex);\n}\n\nclass Dexie$1 {\n    constructor(name, options) {\n        this._middlewares = {};\n        this.verno = 0;\n        const deps = Dexie$1.dependencies;\n        this._options = options = {\n            addons: Dexie$1.addons,\n            autoOpen: true,\n            indexedDB: deps.indexedDB,\n            IDBKeyRange: deps.IDBKeyRange,\n            ...options\n        };\n        this._deps = {\n            indexedDB: options.indexedDB,\n            IDBKeyRange: options.IDBKeyRange\n        };\n        const { addons, } = options;\n        this._dbSchema = {};\n        this._versions = [];\n        this._storeNames = [];\n        this._allTables = {};\n        this.idbdb = null;\n        this._novip = this;\n        const state = {\n            dbOpenError: null,\n            isBeingOpened: false,\n            onReadyBeingFired: null,\n            openComplete: false,\n            dbReadyResolve: nop,\n            dbReadyPromise: null,\n            cancelOpen: nop,\n            openCanceller: null,\n            autoSchema: true,\n            PR1398_maxLoop: 3\n        };\n        state.dbReadyPromise = new DexiePromise(resolve => {\n            state.dbReadyResolve = resolve;\n        });\n        state.openCanceller = new DexiePromise((_, reject) => {\n            state.cancelOpen = reject;\n        });\n        this._state = state;\n        this.name = name;\n        this.on = Events(this, \"populate\", \"blocked\", \"versionchange\", \"close\", { ready: [promisableChain, nop] });\n        this.on.ready.subscribe = override(this.on.ready.subscribe, subscribe => {\n            return (subscriber, bSticky) => {\n                Dexie$1.vip(() => {\n                    const state = this._state;\n                    if (state.openComplete) {\n                        if (!state.dbOpenError)\n                            DexiePromise.resolve().then(subscriber);\n                        if (bSticky)\n                            subscribe(subscriber);\n                    }\n                    else if (state.onReadyBeingFired) {\n                        state.onReadyBeingFired.push(subscriber);\n                        if (bSticky)\n                            subscribe(subscriber);\n                    }\n                    else {\n                        subscribe(subscriber);\n                        const db = this;\n                        if (!bSticky)\n                            subscribe(function unsubscribe() {\n                                db.on.ready.unsubscribe(subscriber);\n                                db.on.ready.unsubscribe(unsubscribe);\n                            });\n                    }\n                });\n            };\n        });\n        this.Collection = createCollectionConstructor(this);\n        this.Table = createTableConstructor(this);\n        this.Transaction = createTransactionConstructor(this);\n        this.Version = createVersionConstructor(this);\n        this.WhereClause = createWhereClauseConstructor(this);\n        this.on(\"versionchange\", ev => {\n            if (ev.newVersion > 0)\n                console.warn(`Another connection wants to upgrade database '${this.name}'. Closing db now to resume the upgrade.`);\n            else\n                console.warn(`Another connection wants to delete database '${this.name}'. Closing db now to resume the delete request.`);\n            this.close();\n        });\n        this.on(\"blocked\", ev => {\n            if (!ev.newVersion || ev.newVersion < ev.oldVersion)\n                console.warn(`Dexie.delete('${this.name}') was blocked`);\n            else\n                console.warn(`Upgrade '${this.name}' blocked by other connection holding version ${ev.oldVersion / 10}`);\n        });\n        this._maxKey = getMaxKey(options.IDBKeyRange);\n        this._createTransaction = (mode, storeNames, dbschema, parentTransaction) => new this.Transaction(mode, storeNames, dbschema, this._options.chromeTransactionDurability, parentTransaction);\n        this._fireOnBlocked = ev => {\n            this.on(\"blocked\").fire(ev);\n            connections\n                .filter(c => c.name === this.name && c !== this && !c._state.vcFired)\n                .map(c => c.on(\"versionchange\").fire(ev));\n        };\n        this.use(virtualIndexMiddleware);\n        this.use(hooksMiddleware);\n        this.use(observabilityMiddleware);\n        this.use(cacheExistingValuesMiddleware);\n        this.vip = Object.create(this, { _vip: { value: true } });\n        addons.forEach(addon => addon(this));\n    }\n    version(versionNumber) {\n        if (isNaN(versionNumber) || versionNumber < 0.1)\n            throw new exceptions.Type(`Given version is not a positive number`);\n        versionNumber = Math.round(versionNumber * 10) / 10;\n        if (this.idbdb || this._state.isBeingOpened)\n            throw new exceptions.Schema(\"Cannot add version when database is open\");\n        this.verno = Math.max(this.verno, versionNumber);\n        const versions = this._versions;\n        var versionInstance = versions.filter(v => v._cfg.version === versionNumber)[0];\n        if (versionInstance)\n            return versionInstance;\n        versionInstance = new this.Version(versionNumber);\n        versions.push(versionInstance);\n        versions.sort(lowerVersionFirst);\n        versionInstance.stores({});\n        this._state.autoSchema = false;\n        return versionInstance;\n    }\n    _whenReady(fn) {\n        return (this.idbdb && (this._state.openComplete || PSD.letThrough || this._vip)) ? fn() : new DexiePromise((resolve, reject) => {\n            if (this._state.openComplete) {\n                return reject(new exceptions.DatabaseClosed(this._state.dbOpenError));\n            }\n            if (!this._state.isBeingOpened) {\n                if (!this._options.autoOpen) {\n                    reject(new exceptions.DatabaseClosed());\n                    return;\n                }\n                this.open().catch(nop);\n            }\n            this._state.dbReadyPromise.then(resolve, reject);\n        }).then(fn);\n    }\n    use({ stack, create, level, name }) {\n        if (name)\n            this.unuse({ stack, name });\n        const middlewares = this._middlewares[stack] || (this._middlewares[stack] = []);\n        middlewares.push({ stack, create, level: level == null ? 10 : level, name });\n        middlewares.sort((a, b) => a.level - b.level);\n        return this;\n    }\n    unuse({ stack, name, create }) {\n        if (stack && this._middlewares[stack]) {\n            this._middlewares[stack] = this._middlewares[stack].filter(mw => create ? mw.create !== create :\n                name ? mw.name !== name :\n                    false);\n        }\n        return this;\n    }\n    open() {\n        return dexieOpen(this);\n    }\n    _close() {\n        const state = this._state;\n        const idx = connections.indexOf(this);\n        if (idx >= 0)\n            connections.splice(idx, 1);\n        if (this.idbdb) {\n            try {\n                this.idbdb.close();\n            }\n            catch (e) { }\n            this._novip.idbdb = null;\n        }\n        state.dbReadyPromise = new DexiePromise(resolve => {\n            state.dbReadyResolve = resolve;\n        });\n        state.openCanceller = new DexiePromise((_, reject) => {\n            state.cancelOpen = reject;\n        });\n    }\n    close() {\n        this._close();\n        const state = this._state;\n        this._options.autoOpen = false;\n        state.dbOpenError = new exceptions.DatabaseClosed();\n        if (state.isBeingOpened)\n            state.cancelOpen(state.dbOpenError);\n    }\n    delete() {\n        const hasArguments = arguments.length > 0;\n        const state = this._state;\n        return new DexiePromise((resolve, reject) => {\n            const doDelete = () => {\n                this.close();\n                var req = this._deps.indexedDB.deleteDatabase(this.name);\n                req.onsuccess = wrap(() => {\n                    _onDatabaseDeleted(this._deps, this.name);\n                    resolve();\n                });\n                req.onerror = eventRejectHandler(reject);\n                req.onblocked = this._fireOnBlocked;\n            };\n            if (hasArguments)\n                throw new exceptions.InvalidArgument(\"Arguments not allowed in db.delete()\");\n            if (state.isBeingOpened) {\n                state.dbReadyPromise.then(doDelete);\n            }\n            else {\n                doDelete();\n            }\n        });\n    }\n    backendDB() {\n        return this.idbdb;\n    }\n    isOpen() {\n        return this.idbdb !== null;\n    }\n    hasBeenClosed() {\n        const dbOpenError = this._state.dbOpenError;\n        return dbOpenError && (dbOpenError.name === 'DatabaseClosed');\n    }\n    hasFailed() {\n        return this._state.dbOpenError !== null;\n    }\n    dynamicallyOpened() {\n        return this._state.autoSchema;\n    }\n    get tables() {\n        return keys(this._allTables).map(name => this._allTables[name]);\n    }\n    transaction() {\n        const args = extractTransactionArgs.apply(this, arguments);\n        return this._transaction.apply(this, args);\n    }\n    _transaction(mode, tables, scopeFunc) {\n        let parentTransaction = PSD.trans;\n        if (!parentTransaction || parentTransaction.db !== this || mode.indexOf('!') !== -1)\n            parentTransaction = null;\n        const onlyIfCompatible = mode.indexOf('?') !== -1;\n        mode = mode.replace('!', '').replace('?', '');\n        let idbMode, storeNames;\n        try {\n            storeNames = tables.map(table => {\n                var storeName = table instanceof this.Table ? table.name : table;\n                if (typeof storeName !== 'string')\n                    throw new TypeError(\"Invalid table argument to Dexie.transaction(). Only Table or String are allowed\");\n                return storeName;\n            });\n            if (mode == \"r\" || mode === READONLY)\n                idbMode = READONLY;\n            else if (mode == \"rw\" || mode == READWRITE)\n                idbMode = READWRITE;\n            else\n                throw new exceptions.InvalidArgument(\"Invalid transaction mode: \" + mode);\n            if (parentTransaction) {\n                if (parentTransaction.mode === READONLY && idbMode === READWRITE) {\n                    if (onlyIfCompatible) {\n                        parentTransaction = null;\n                    }\n                    else\n                        throw new exceptions.SubTransaction(\"Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY\");\n                }\n                if (parentTransaction) {\n                    storeNames.forEach(storeName => {\n                        if (parentTransaction && parentTransaction.storeNames.indexOf(storeName) === -1) {\n                            if (onlyIfCompatible) {\n                                parentTransaction = null;\n                            }\n                            else\n                                throw new exceptions.SubTransaction(\"Table \" + storeName +\n                                    \" not included in parent transaction.\");\n                        }\n                    });\n                }\n                if (onlyIfCompatible && parentTransaction && !parentTransaction.active) {\n                    parentTransaction = null;\n                }\n            }\n        }\n        catch (e) {\n            return parentTransaction ?\n                parentTransaction._promise(null, (_, reject) => { reject(e); }) :\n                rejection(e);\n        }\n        const enterTransaction = enterTransactionScope.bind(null, this, idbMode, storeNames, parentTransaction, scopeFunc);\n        return (parentTransaction ?\n            parentTransaction._promise(idbMode, enterTransaction, \"lock\") :\n            PSD.trans ?\n                usePSD(PSD.transless, () => this._whenReady(enterTransaction)) :\n                this._whenReady(enterTransaction));\n    }\n    table(tableName) {\n        if (!hasOwn(this._allTables, tableName)) {\n            throw new exceptions.InvalidTable(`Table ${tableName} does not exist`);\n        }\n        return this._allTables[tableName];\n    }\n}\n\nconst symbolObservable = typeof Symbol !== \"undefined\" && \"observable\" in Symbol\n    ? Symbol.observable\n    : \"@@observable\";\nclass Observable {\n    constructor(subscribe) {\n        this._subscribe = subscribe;\n    }\n    subscribe(x, error, complete) {\n        return this._subscribe(!x || typeof x === \"function\" ? { next: x, error, complete } : x);\n    }\n    [symbolObservable]() {\n        return this;\n    }\n}\n\nfunction extendObservabilitySet(target, newSet) {\n    keys(newSet).forEach(part => {\n        const rangeSet = target[part] || (target[part] = new RangeSet());\n        mergeRanges(rangeSet, newSet[part]);\n    });\n    return target;\n}\n\nfunction liveQuery(querier) {\n    let hasValue = false;\n    let currentValue = undefined;\n    const observable = new Observable((observer) => {\n        const scopeFuncIsAsync = isAsyncFunction(querier);\n        function execute(subscr) {\n            if (scopeFuncIsAsync) {\n                incrementExpectedAwaits();\n            }\n            const exec = () => newScope(querier, { subscr, trans: null });\n            const rv = PSD.trans\n                ?\n                    usePSD(PSD.transless, exec)\n                : exec();\n            if (scopeFuncIsAsync) {\n                rv.then(decrementExpectedAwaits, decrementExpectedAwaits);\n            }\n            return rv;\n        }\n        let closed = false;\n        let accumMuts = {};\n        let currentObs = {};\n        const subscription = {\n            get closed() {\n                return closed;\n            },\n            unsubscribe: () => {\n                closed = true;\n                globalEvents.storagemutated.unsubscribe(mutationListener);\n            },\n        };\n        observer.start && observer.start(subscription);\n        let querying = false, startedListening = false;\n        function shouldNotify() {\n            return keys(currentObs).some((key) => accumMuts[key] && rangesOverlap(accumMuts[key], currentObs[key]));\n        }\n        const mutationListener = (parts) => {\n            extendObservabilitySet(accumMuts, parts);\n            if (shouldNotify()) {\n                doQuery();\n            }\n        };\n        const doQuery = () => {\n            if (querying || closed)\n                return;\n            accumMuts = {};\n            const subscr = {};\n            const ret = execute(subscr);\n            if (!startedListening) {\n                globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, mutationListener);\n                startedListening = true;\n            }\n            querying = true;\n            Promise.resolve(ret).then((result) => {\n                hasValue = true;\n                currentValue = result;\n                querying = false;\n                if (closed)\n                    return;\n                if (shouldNotify()) {\n                    doQuery();\n                }\n                else {\n                    accumMuts = {};\n                    currentObs = subscr;\n                    observer.next && observer.next(result);\n                }\n            }, (err) => {\n                querying = false;\n                hasValue = false;\n                observer.error && observer.error(err);\n                subscription.unsubscribe();\n            });\n        };\n        doQuery();\n        return subscription;\n    });\n    observable.hasValue = () => hasValue;\n    observable.getValue = () => currentValue;\n    return observable;\n}\n\nlet domDeps;\ntry {\n    domDeps = {\n        indexedDB: _global.indexedDB || _global.mozIndexedDB || _global.webkitIndexedDB || _global.msIndexedDB,\n        IDBKeyRange: _global.IDBKeyRange || _global.webkitIDBKeyRange\n    };\n}\ncatch (e) {\n    domDeps = { indexedDB: null, IDBKeyRange: null };\n}\n\nconst Dexie = Dexie$1;\nprops(Dexie, {\n    ...fullNameExceptions,\n    delete(databaseName) {\n        const db = new Dexie(databaseName, { addons: [] });\n        return db.delete();\n    },\n    exists(name) {\n        return new Dexie(name, { addons: [] }).open().then(db => {\n            db.close();\n            return true;\n        }).catch('NoSuchDatabaseError', () => false);\n    },\n    getDatabaseNames(cb) {\n        try {\n            return getDatabaseNames(Dexie.dependencies).then(cb);\n        }\n        catch (_a) {\n            return rejection(new exceptions.MissingAPI());\n        }\n    },\n    defineClass() {\n        function Class(content) {\n            extend(this, content);\n        }\n        return Class;\n    },\n    ignoreTransaction(scopeFunc) {\n        return PSD.trans ?\n            usePSD(PSD.transless, scopeFunc) :\n            scopeFunc();\n    },\n    vip,\n    async: function (generatorFn) {\n        return function () {\n            try {\n                var rv = awaitIterator(generatorFn.apply(this, arguments));\n                if (!rv || typeof rv.then !== 'function')\n                    return DexiePromise.resolve(rv);\n                return rv;\n            }\n            catch (e) {\n                return rejection(e);\n            }\n        };\n    },\n    spawn: function (generatorFn, args, thiz) {\n        try {\n            var rv = awaitIterator(generatorFn.apply(thiz, args || []));\n            if (!rv || typeof rv.then !== 'function')\n                return DexiePromise.resolve(rv);\n            return rv;\n        }\n        catch (e) {\n            return rejection(e);\n        }\n    },\n    currentTransaction: {\n        get: () => PSD.trans || null\n    },\n    waitFor: function (promiseOrFunction, optionalTimeout) {\n        const promise = DexiePromise.resolve(typeof promiseOrFunction === 'function' ?\n            Dexie.ignoreTransaction(promiseOrFunction) :\n            promiseOrFunction)\n            .timeout(optionalTimeout || 60000);\n        return PSD.trans ?\n            PSD.trans.waitFor(promise) :\n            promise;\n    },\n    Promise: DexiePromise,\n    debug: {\n        get: () => debug,\n        set: value => {\n            setDebug(value, value === 'dexie' ? () => true : dexieStackFrameFilter);\n        }\n    },\n    derive: derive,\n    extend: extend,\n    props: props,\n    override: override,\n    Events: Events,\n    on: globalEvents,\n    liveQuery,\n    extendObservabilitySet,\n    getByKeyPath: getByKeyPath,\n    setByKeyPath: setByKeyPath,\n    delByKeyPath: delByKeyPath,\n    shallowClone: shallowClone,\n    deepClone: deepClone,\n    getObjectDiff: getObjectDiff,\n    cmp,\n    asap: asap$1,\n    minKey: minKey,\n    addons: [],\n    connections: connections,\n    errnames: errnames,\n    dependencies: domDeps,\n    semVer: DEXIE_VERSION,\n    version: DEXIE_VERSION.split('.')\n        .map(n => parseInt(n))\n        .reduce((p, c, i) => p + (c / Math.pow(10, i * 2))),\n});\nDexie.maxKey = getMaxKey(Dexie.dependencies.IDBKeyRange);\n\nif (typeof dispatchEvent !== 'undefined' && typeof addEventListener !== 'undefined') {\n    globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, updatedParts => {\n        if (!propagatingLocally) {\n            let event;\n            if (isIEOrEdge) {\n                event = document.createEvent('CustomEvent');\n                event.initCustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, true, true, updatedParts);\n            }\n            else {\n                event = new CustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, {\n                    detail: updatedParts\n                });\n            }\n            propagatingLocally = true;\n            dispatchEvent(event);\n            propagatingLocally = false;\n        }\n    });\n    addEventListener(STORAGE_MUTATED_DOM_EVENT_NAME, ({ detail }) => {\n        if (!propagatingLocally) {\n            propagateLocally(detail);\n        }\n    });\n}\nfunction propagateLocally(updateParts) {\n    let wasMe = propagatingLocally;\n    try {\n        propagatingLocally = true;\n        globalEvents.storagemutated.fire(updateParts);\n    }\n    finally {\n        propagatingLocally = wasMe;\n    }\n}\nlet propagatingLocally = false;\n\nif (typeof BroadcastChannel !== 'undefined') {\n    const bc = new BroadcastChannel(STORAGE_MUTATED_DOM_EVENT_NAME);\n    if (typeof bc.unref === 'function') {\n        bc.unref();\n    }\n    globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, (changedParts) => {\n        if (!propagatingLocally) {\n            bc.postMessage(changedParts);\n        }\n    });\n    bc.onmessage = (ev) => {\n        if (ev.data)\n            propagateLocally(ev.data);\n    };\n}\nelse if (typeof self !== 'undefined' && typeof navigator !== 'undefined') {\n    globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, (changedParts) => {\n        try {\n            if (!propagatingLocally) {\n                if (typeof localStorage !== 'undefined') {\n                    localStorage.setItem(STORAGE_MUTATED_DOM_EVENT_NAME, JSON.stringify({\n                        trig: Math.random(),\n                        changedParts,\n                    }));\n                }\n                if (typeof self['clients'] === 'object') {\n                    [...self['clients'].matchAll({ includeUncontrolled: true })].forEach((client) => client.postMessage({\n                        type: STORAGE_MUTATED_DOM_EVENT_NAME,\n                        changedParts,\n                    }));\n                }\n            }\n        }\n        catch (_a) { }\n    });\n    if (typeof addEventListener !== 'undefined') {\n        addEventListener('storage', (ev) => {\n            if (ev.key === STORAGE_MUTATED_DOM_EVENT_NAME) {\n                const data = JSON.parse(ev.newValue);\n                if (data)\n                    propagateLocally(data.changedParts);\n            }\n        });\n    }\n    const swContainer = self.document && navigator.serviceWorker;\n    if (swContainer) {\n        swContainer.addEventListener('message', propagateMessageLocally);\n    }\n}\nfunction propagateMessageLocally({ data }) {\n    if (data && data.type === STORAGE_MUTATED_DOM_EVENT_NAME) {\n        propagateLocally(data.changedParts);\n    }\n}\n\nDexiePromise.rejectionMapper = mapError;\nsetDebug(debug, dexieStackFrameFilter);\n\nexport { Dexie$1 as Dexie, RangeSet, Dexie$1 as default, liveQuery, mergeRanges, rangesOverlap };\n//# sourceMappingURL=dexie.mjs.map\n"],"names":["WHITE","BLACK","PAWN","BISHOP","ROOK","QUEEN","KING","DEFAULT_POSITION","EMPTY","FLAGS","NORMAL","CAPTURE","BIG_PAWN","EP_CAPTURE","PROMOTION","KSIDE_CASTLE","QSIDE_CASTLE","BITS","Ox88","a8","b8","c8","d8","e8","f8","g8","h8","a7","b7","c7","d7","e7","f7","g7","h7","a6","b6","c6","d6","e6","f6","g6","h6","a5","b5","c5","d5","e5","f5","g5","h5","a4","b4","c4","d4","e4","f4","g4","h4","a3","b3","c3","d3","e3","f3","g3","h3","a2","b2","c2","d2","e2","f2","g2","h2","a1","b1","c1","d1","e1","f1","g1","h1","PAWN_OFFSETS","b","w","PIECE_OFFSETS","n","r","q","k","ATTACKS","RAYS","PIECE_MASKS","p","PROMOTIONS","SIDES","ROOKS","square","flag","SECOND_RANK","TERMINATION_MARKERS","rank","file","isDigit","c","indexOf","algebraic","f","substring","swapColor","color","addMove","moves","from","to","piece","captured","arguments","length","undefined","flags","push","i","promotion","inferPieceType","san","pieceType","charAt","match","toLowerCase","strippedSan","move","replace","trimFen","fen","split","slice","join","Chess","constructor","_defineProperty","Array","this","load","clear","preserveHeaders","_board","_kings","_turn","_castling","_epSquare","_halfMoves","_moveNumber","_history","_comments","_header","_positionCounts","Proxy","get","target","position","Object","keys","set","count","trimmedFen","removeHeader","key","skipValidation","tokens","adjustments","concat","ok","error","moveNumber","parseInt","isNaN","halfMoves","test","rows","sumFields","previousWasNumber","kings","regex","some","char","toUpperCase","validateFen","Error","_put","type","_updateSetup","empty","castling","epSquare","bigPawnSquare","squares","_this$_board$square","_this$_board$square2","_makeMove","isLegal","_isKingAttacked","_undoMove","reset","put","_ref","_updateCastlingRights","_updateEnPassantSquare","_ref2","sq","currentPieceOnSquare","remove","_this$_board$Ox88$e","_this$_board$Ox88$e2","_this$_board$Ox88$e3","_this$_board$Ox88$e4","_this$_board$Ox88$a","_this$_board$Ox88$a2","_this$_board$Ox88$h","_this$_board$Ox88$h2","_this$_board$Ox88$a3","_this$_board$Ox88$a4","_this$_board$Ox88$h3","_this$_board$Ox88$h4","whiteKingInPlace","blackKingInPlace","_this$_board$currentS","_this$_board$currentS2","startSquare","currentSquare","attackers","_this$_board$square3","_this$_board$square4","_attacked","difference","index","offset","j","blocked","isAttacked","attackedBy","isCheck","inCheck","isCheckmate","_moves","isStalemate","isInsufficientMaterial","pieces","bishops","numPieces","squareColor","sum","len","_getRepetitionCount","isThreefoldRepetition","isDraw","isGameOver","verbose","map","_makePretty","_moveToSan","legal","forSquare","forPiece","us","them","firstSquare","lastSquare","singleSquare","_this$_board$to","castlingFrom","castlingTo","legalMoves","strict","moveObj","_moveFromSan","JSON","stringify","prettyMove","after","_push","turn","undo","old","pop","pgn","newline","maxWidth","result","headerExists","appendComment","moveString","comment","delimiter","reversedHistory","prefix","Result","strip","wrapComment","width","token","currentWidth","includes","header","_len","args","_key","loadPgn","newlineChar","mask","str","trim","headerRegexResults","RegExp","exec","headerString","headers","headerObj","value","parsePgnHeader","encodeComment","s","charCodeAt","toString","encodeURIComponent","toHex","decodeComment","startsWith","endsWith","decodeURIComponent","fromHex","ms","_match","bracket","semicolon","ravRegex","filter","halfMove","output","disambiguator","ambiguities","sameRank","sameFile","ambigFrom","ambigTo","getDisambiguator","cleanMove","matches","overlyDisambiguated","ascii","perft","depth","nodes","uglyMove","prettyFlags","fromAlgebraic","toAlgebraic","lan","before","board","row","history","moveHistory","_pruneComments","currentComments","copyComment","getComment","setComment","deleteComment","getComments","deleteComments","setCastlingRights","rights","side","getCastlingRights","obj","defineProperty","enumerable","configurable","writable","toPrimitive","t","e","Symbol","call","TypeError","String","Number","toPropertyKey","_typeof","o","iterator","prototype","globalThis","self","window","global","isArray","forEach","Promise","getPrototypeOf","hasOwnProperty","a","Reflect","ownKeys","l","u","create","extend","bind","h","getOwnPropertyDescriptor","d","y","m","v","setImmediate","setTimeout","g","reduce","substr","_","isFrozen","splice","x","apply","E","P","K","O","WeakMap","S","A","C","D","I","B","next","done","T","toStringTag","R","location","href","F","M","libraryFilter","N","stack","$","name","message","U","L","V","VersionChanged","DatabaseClosed","Abort","TransactionInactive","MissingAPI","W","_e","Y","z","failures","failedKeys","successCount","G","failuresByPos","_stack","H","Q","X","inner","Syntax","SyntaxError","Type","Range","RangeError","J","Z","ee","te","ne","re","se","onsuccess","onerror","ie","oe","ae","ue","then","ModifyError","DexieError","BulkError","le","ce","he","de","fe","resolve","crypto","subtle","digest","Uint8Array","pe","ye","me","ve","ge","$e","MutationObserver","document","createElement","observe","attributes","setAttribute","be","Se","we","xe","ke","Ee","Pe","Ke","id","ref","unhandleds","onunhandled","dt","pgp","env","finalize","Oe","Ae","Ce","je","_listeners","onuncatched","_lib","_PSD","_stackHolder","_prev","_numPrev","_state","_value","Te","Be","De","Xe","tt","Fe","Ie","lt","qe","onFulfilled","onRejected","reject","psd","Ue","_then","Re","Le","_promise","Ve","Me","Ne","We","Ye","it","catch","finally","timeout","Timeout","clearTimeout","ot","all","nt","race","PSD","totalEchoes","newPSD","Ze","usePSD","at","scheduler","rejectionMapper","follow","allSettled","status","reason","any","AggregateError","ze","awaits","echoes","Ge","He","Qe","Je","parent","PromiseProp","nthen","ct","gthen","et","ft","rt","st","ut","ht","promise","createEvent","initEvent","CustomEvent","detail","dispatchEvent","PromiseRejectionEvent","onunhandledrejection","defaultPrevented","console","warn","pt","idbdb","openComplete","letThrough","_vip","_createTransaction","_dbSchema","PR1398_maxLoop","InvalidState","isOpen","_close","open","trans","_completion","dbOpenError","isBeingOpened","_options","autoOpen","dbReadyPromise","yt","mt","fromCharCode","vt","gt","bt","_t","wt","navigator","userAgent","xt","kt","Et","Pt","Kt","Ot","St","At","lower","lowerOpen","upper","upperOpen","Ct","jt","_trans","_tx","schema","NotFound","idbtrans","db","transless","where","first","core","hook","reading","fire","WhereClause","equals","indexes","primKey","compound","every","keyPath","_maxKey","idxByName","_deps","indexedDB","cmp","multi","toCollection","and","limit","each","toArray","Collection","orderBy","reverse","mapToClass","mappedClass","readHook","unsubscribe","defineClass","add","auto","mutate","values","numFailures","lastResult","update","modify","InvalidArgument","delete","range","bulkGet","getMany","bulkAdd","allKeys","wantResults","results","bulkPut","_ref3","bulkDelete","_ref4","Dt","subscribe","addEventType","subscribers","It","Bt","algorithm","or","justLimit","replayFilter","Tt","Rt","Ft","isPrimKey","primaryKey","getIndexByKeyPath","Schema","Mt","openCursor","keysOnly","dir","unique","query","Nt","union","stop","fail","_iterate","qt","valueMapper","start","continue","$t","Ut","NaN","Lt","ArrayBuffer","isView","buffer","byteOffset","byteLength","Vt","_read","_ctx","table","_write","_addAlgorithm","clone","raw","Math","min","sortBy","sort","_ref5","advance","until","last","isMatch","_ondirectionchange","desc","eachKey","eachUniqueKey","eachPrimaryKey","primaryKeys","_ref6","uniqueKeys","firstKey","lastKey","distinct","outbound","extractKey","modifyChunkSize","applyMutateResult","cache","Wt","criteria","changeSpec","_ref7","deleteCallback","Yt","zt","Gt","en","Ht","Zt","Qt","Xt","Jt","between","_cmp","above","aboveOrEqual","below","belowOrEqual","startsWithIgnoreCase","equalsIgnoreCase","anyOfIgnoreCase","startsWithAnyOfIgnoreCase","anyOf","_ascending","_descending","notEqual","inAnyRange","includeLowers","includeUppers","noneOf","_min","_max","startsWithAnyOf","tn","nn","stopPropagation","preventDefault","rn","sn","on","an","_lock","_reculock","lockOwnerFor","_unlock","_blockedFuncs","_locked","shift","mode","OpenFailed","active","transaction","storeNames","durability","chromeTransactionDurability","_reject","onabort","oncomplete","_resolve","storagemutated","mutatedParts","ReadOnly","_root","waitFor","_waitingFor","_waitingQueue","objectStore","_spinCount","abort","_memoizedTables","Table","un","src","ln","cn","hn","only","getMaxKey","dn","fn","pn","yn","mn","upperBound","lowerBound","bound","hasGetAll","objectStoreNames","tables","autoIncrement","isPrimaryKey","indexNames","multiEntry","_ref8","_ref9","_pos","_ref10","getAll","getAllKeys","openKeyCursor","_ref11","___id","continuePrimaryKey","doThrowCursorIsStopped","guardedCallback","_ref12","MIN_KEY","MAX_KEY","vn","_ref13","_novip","_ref14","IDBKeyRange","_ref15","dbcore","_middlewares","gn","_ref16","Transaction","bn","_ref17","_n","_cfg","version","wn","_storeNames","kn","populate","_ref18","_versions","Pn","dbschema","Kn","xn","change","recreate","Upgrade","En","deleteIndex","del","contentUpgrade","deleteObjectStore","contains","def","createObjectStore","createIndex","_ref19","_hasGetAll","WorkerGlobalScope","On","_parseStoresSpec","stores","storesSource","_allTables","upgrade","Sn","_dbNamesDB","Xn","addons","dbnames","An","databases","Cn","jn","userAgentData","setInterval","clearInterval","In","throw","Bn","Tn","PrematureCommit","Rn","Fn","level","isVirtual","keyTail","keyLength","Mn","Nn","deleting","creating","updating","_ref22","_ref23","qn","$n","_cache","Un","Ln","Vn","Gn","Wn","_ref24","zn","up","Hn","_ref25","max","addKey","addKeys","Qn","_ref26","subscr","_ref27","verno","dependencies","onReadyBeingFired","dbReadyResolve","cancelOpen","openCanceller","autoSchema","ready","vip","complete","Version","_IDBKeyRange","newVersion","close","oldVersion","_fireOnBlocked","vcFired","use","round","_whenReady","_ref28","unuse","_ref29","onblocked","onupgradeneeded","allowEmptyDB","deleteDatabase","NoSuchDatabase","pow","_ref20","onversionchange","onclose","_ref21","Dn","doDelete","_ref30","backendDB","hasBeenClosed","hasFailed","dynamicallyOpened","_transaction","SubTransaction","InvalidTable","Jn","observable","Zn","_subscribe","er","nr","mozIndexedDB","webkitIndexedDB","msIndexedDB","webkitIDBKeyRange","rr","sr","ir","exists","getDatabaseNames","_ref31","ignoreTransaction","async","spawn","currentTransaction","debug","derive","props","override","Events","liveQuery","closed","Yn","doQuery","hasValue","getValue","extendObservabilitySet","getByKeyPath","setByKeyPath","delByKeyPath","shallowClone","deepClone","getObjectDiff","asap","minKey","connections","errnames","semVer","maxKey","addEventListener","initCustomEvent","_ref32","BroadcastChannel","unref","postMessage","onmessage","data","localStorage","setItem","trig","random","changedParts","clients","matchAll","includeUncontrolled","parse","newValue","serviceWorker","_ref33"],"sourceRoot":""}